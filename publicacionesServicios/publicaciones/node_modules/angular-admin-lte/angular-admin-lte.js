import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, Renderer2, SkipSelf, ViewChild, ViewChildren, ViewContainerRef, forwardRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NavigationEnd, NavigationStart, PRIMARY_OUTLET, Router, RouterModule } from '@angular/router';
import { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/BehaviorSubject';
import { Title } from '@angular/platform-browser';
import 'rxjs/add/operator/distinctUntilChanged';
import 'rxjs/add/operator/pluck';
import { FormsModule, NG_VALUE_ACCESSOR } from '@angular/forms';

class RoutingService {
    /**
     * \@method constructor
     * @param {?} router
     */
    constructor(router$$1) {
        this.router = router$$1;
        this.onChange = new BehaviorSubject$1(undefined);
        this.events = new BehaviorSubject$1(undefined);
        this.init();
    }
    /**
     * [init description]
     * \@method init
     * @return {?}
     */
    init() {
        this.router.events.subscribe(routeEvent => {
            // https://github.com/angular/angular/issues/17473: event not fired anymore on load for routed component.
            this.events.next(routeEvent);
            if (routeEvent instanceof NavigationEnd) {
                let /** @type {?} */ route = this.router.routerState.root.snapshot, /** @type {?} */ tmpUrl = '', /** @type {?} */ url = '', /** @type {?} */ paths = [], /** @type {?} */ rootRoot = true;
                while (route.children.length) {
                    route = route.firstChild;
                    tmpUrl = `/${this.createUrl(route)}`;
                    if (route.outlet !== PRIMARY_OUTLET || (!route.routeConfig.path && !rootRoot)) {
                        continue;
                    }
                    rootRoot = false;
                    if (route.params || route.data) {
                        for (let /** @type {?} */ key in route.params) {
                            if (route.data['title']) {
                                route.data['title'] = route.data['title'].replace(`:${key}`, route.params[key]);
                            }
                            if (route.data['breadcrumbs']) {
                                route.data['breadcrumbs'] = route.data['breadcrumbs'].replace(`:${key}`, route.params[key]);
                            }
                            if (route.data['description']) {
                                route.data['description'] = route.data['description'].replace(`:${key}`, route.params[key]);
                            }
                        }
                    }
                    if (tmpUrl === '/') {
                        paths.push(this.createBreadcrumb(route, tmpUrl));
                    }
                    else {
                        url += tmpUrl;
                        paths.push(this.createBreadcrumb(route, url));
                    }
                }
                this.onChange.next(paths);
            }
        });
    }
    /**
     * [createBreadcrumb description]
     * \@method createBreadcrumb
     * @param {?} route
     * @param {?} url
     * @return {?}
     */
    createBreadcrumb(route, url) {
        if (route.children.length !== 0 && route.firstChild.routeConfig.path) {
            var /** @type {?} */ isUrl = true;
            if (url !== '/' && !route.routeConfig.loadChildren && !route.routeConfig.component && !this.isChildrenSelfRoute(route)) {
                isUrl = false;
            }
        }
        return {
            data: route.data,
            params: route.params,
            url: isUrl ? url : null
        };
    }
    /**
     * [isChildrenSelfRoute description]
     * \@method isChildrenSelfRoute
     * @param {?} route
     * @return {?}
     */
    isChildrenSelfRoute(route) {
        let /** @type {?} */ children = route.routeConfig.children;
        for (let /** @type {?} */ index in children) {
            if (children[index].path === '' && (children[index].component || children[index].loadChildren)) {
                return true;
            }
        }
    }
    /**
     * [createUrl description]
     * \@method createUrl
     * @param {?} route
     * @return {?}
     */
    createUrl(route) {
        return route.url.map(urlSegment => urlSegment.toString()).join('/');
    }
}
RoutingService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
RoutingService.ctorParameters = () => [
    { type: Router, },
];

class BreadcrumbsComponent {
    /**
     * \@method constructor
     * @param {?} routingService
     * @param {?} changeDetectorRef
     */
    constructor(routingService, changeDetectorRef) {
        this.routingService = routingService;
        this.changeDetectorRef = changeDetectorRef;
        this.homeIcon = 'fa fa-home';
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.subscription = this.routingService.onChange.subscribe(value => {
            this.breadcrumbs = value;
        });
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
BreadcrumbsComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-breadcrumbs',
                template: `
    <ol class="breadcrumb">
      <li *ngFor="let breadcrumb of breadcrumbs; let first = first; let last = last" [class.active]="last || !breadcrumb.url">
        <a *ngIf="breadcrumb.url" [routerLink]="breadcrumb.url">
          <i *ngIf="first" ngClass="{{homeIcon}}"></i>
          <ng-template [ngIf]="breadcrumb.data.breadcrumbs">{{breadcrumb.data.breadcrumbs}}</ng-template>
          <ng-template [ngIf]="!breadcrumb.data.breadcrumbs">{{breadcrumb.data.title}}</ng-template>
        </a>
        <ng-template [ngIf]="!breadcrumb.url">
          <i *ngIf="first" ngClass="{{homeIcon}}"></i>
          <ng-template [ngIf]="breadcrumb.data.breadcrumbs">{{breadcrumb.data.breadcrumbs}}</ng-template>
          <ng-template [ngIf]="!breadcrumb.data.breadcrumbs">{{breadcrumb.data.title}}</ng-template>
        </ng-template>
      </li>
    </ol>
  `,
                styles: [`
    .breadcrumb {
      float: right;
      background: transparent;
      margin-top: 0;
      margin-bottom: 0;
      font-size: 12px;
      padding: 7px 5px;
      position: absolute;
      top: 15px;
      right: 10px;
      border-radius: 2px;
    }

    .breadcrumb > li > a {
      color: #444;
      text-decoration: none;
      display: inline-block;
    }

    .breadcrumb > li > a > .fa,
    .breadcrumb > li > a > .glyphicon,
    .breadcrumb > li > a > .ion {
      margin-right: 5px;
    }
  `]
            },] },
];
/**
 * @nocollapse
 */
BreadcrumbsComponent.ctorParameters = () => [
    { type: RoutingService, },
    { type: ChangeDetectorRef, },
];
BreadcrumbsComponent.propDecorators = {
    'homeIcon': [{ type: Input },],
};

class BreadcrumbsModule {
}
BreadcrumbsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule],
                exports: [BreadcrumbsComponent],
                declarations: [BreadcrumbsComponent]
            },] },
];
/**
 * @nocollapse
 */
BreadcrumbsModule.ctorParameters = () => [];

class LayoutStore {
    /**
     * \@method constructor
     * @param {?} layoutConfig
     */
    constructor(layoutConfig) {
        this.initialLayoutState = {
            isSidebarLeftCollapsed: false,
            isSidebarLeftExpandOnOver: false,
            isSidebarLeftMouseOver: false,
            isSidebarLeftMini: true,
            sidebarRightSkin: 'dark',
            isSidebarRightCollapsed: true,
            isSidebarRightOverContent: true,
            layout: 'normal',
            sidebarLeftMenu: [],
            skin: 'blue',
        };
        if (layoutConfig) {
            this.initialLayoutState = Object.assign(this.initialLayoutState, layoutConfig);
        }
        this._layoutState = new BehaviorSubject$1(this.initialLayoutState);
        this.layoutState = this._layoutState.asObservable();
    }
    /**
     * [windowInnerHeight description]
     * \@method windowInnerHeight
     * @return {?}
     */
    get windowInnerHeight() {
        return (this.layoutState.pluck('windowInnerHeight').distinctUntilChanged());
    }
    /**
     * [windowInnerWidth description]
     * \@method windowInnerWidth
     * @return {?}
     */
    get windowInnerWidth() {
        return (this.layoutState.pluck('windowInnerWidth').distinctUntilChanged());
    }
    /**
     * [isSidebarLeftCollapsed description]
     * @return {?}
     */
    get isSidebarLeftCollapsed() {
        return (this.layoutState.pluck('isSidebarLeftCollapsed').distinctUntilChanged());
    }
    /**
     * [isSidebarLeftExpandOnOver description]
     * \@method isSidebarLeftExpandOnOver
     * @return {?}
     */
    get isSidebarLeftExpandOnOver() {
        return (this.layoutState.pluck('isSidebarLeftExpandOnOver').distinctUntilChanged());
    }
    /**
     * [isSidebarLeftMouseOver description]
     * \@method isSidebarLeftMouseOver
     * @return {?}
     */
    get isSidebarLeftMouseOver() {
        return (this.layoutState.pluck('isSidebarLeftMouseOver').distinctUntilChanged());
    }
    /**
     * [isSidebarLeftMini description]
     * \@method isSidebarLeftMini
     * @return {?}
     */
    get isSidebarLeftMini() {
        return (this.layoutState.pluck('isSidebarLeftMini').distinctUntilChanged());
    }
    /**
     * [sidebarRightSkin description]
     * \@method sidebarRightSkin
     * @return {?}
     */
    get sidebarRightSkin() {
        return (this.layoutState.pluck('sidebarRightSkin').distinctUntilChanged());
    }
    /**
     * [isSidebarRightCollapsed description]
     * @return {?}
     */
    get isSidebarRightCollapsed() {
        return (this.layoutState.pluck('isSidebarRightCollapsed').distinctUntilChanged());
    }
    /**
     * [isSidebarRightOverContent description]
     * \@method isSidebarRightOverContent
     * @return {?}
     */
    get isSidebarRightOverContent() {
        return (this.layoutState.pluck('isSidebarRightOverContent').distinctUntilChanged());
    }
    /**
     * [sidebarLeftMenu description]
     * \@method sidebarLeftMenu
     * @return {?}
     */
    get sidebarLeftMenu() {
        return (this.layoutState.pluck('sidebarLeftMenu').distinctUntilChanged());
    }
    /**
     * [sidebarLeftElementHeight description]
     * \@method sidebarLeftElementHeight
     * @return {?}
     */
    get sidebarLeftElementHeight() {
        return (this.layoutState.pluck('sidebarLeftElementHeight').distinctUntilChanged());
    }
    /**
     * [layoutType description]
     * \@method layoutType
     * @return {?}
     */
    get layout() {
        return (this.layoutState.pluck('layout').distinctUntilChanged());
    }
    /**
     * [skin description]
     * \@method skin
     * @return {?}
     */
    get skin() {
        return (this.layoutState.pluck('skin').distinctUntilChanged());
    }
    /**
     * [wrapperClasses description]
     * \@method wrapperClasses
     * @return {?}
     */
    get wrapperClasses() {
        return (this.layoutState.pluck('wrapperClasses').distinctUntilChanged());
    }
    /**
     * [sidebarLeftCollapsed description]
     * \@method sidebarLeftCollapsed
     * @param {?=} value
     * @return {?}
     */
    sidebarLeftCollapsed(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarLeftCollapsed: value }));
    }
    /**
     * [sidebarLeftExpandOnOver description]
     * \@method sidebarLeftExpandOnOver
     * @param {?=} value
     * @return {?}
     */
    sidebarLeftExpandOnOver(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarLeftExpandOnOver: value }));
    }
    /**
     * [setSidebarLeftElementHeight description]
     * \@method setSidebarLeftElementHeight
     * @param {?} value
     * @return {?}
     */
    setSidebarLeftElementHeight(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { sidebarLeftElementHeight: value }));
    }
    /**
     * [setSidebarRightSkin description]
     * \@method setSidebarRightSkin
     * @param {?=} value
     * @return {?}
     */
    setSidebarRightSkin(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { sidebarRightSkin: value }));
    }
    /**
     * [sidebarLeftMouseOver description]
     * \@method sidebarLeftMouseOver
     * @param {?=} value
     * @return {?}
     */
    sidebarLeftMouseOver(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarLeftMouseOver: value }));
    }
    /**
     * [sidebarLeftMini description]
     * \@method sidebarLeftMini
     * @param {?=} value
     * @return {?}
     */
    sidebarLeftMini(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarLeftMini: value }));
    }
    /**
     * [sidebarRightCollapsed description]
     * \@method sidebarRightCollapsed
     * @param {?=} value
     * @return {?}
     */
    sidebarRightCollapsed(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarRightCollapsed: value }));
    }
    /**
     * [sidebarRightOverContent description]
     * \@method sidebarRightOverContent
     * @param {?=} value
     * @return {?}
     */
    sidebarRightOverContent(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarRightOverContent: value }));
    }
    /**
     * [setSidebarLeftMenu description]
     * \@method setSidebarLeftMenu
     * @param {?} value
     * @return {?}
     */
    setSidebarLeftMenu(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { sidebarLeftMenu: value }));
    }
    /**
     * [setLayout description]
     * \@method setLayout
     * @param {?} value
     * @return {?}
     */
    setLayout(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { layout: value }));
    }
    /**
     * [setSkin description]
     * \@method setSkin
     * @param {?} value
     * @return {?}
     */
    setSkin(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { skin: value }));
    }
    /**
     * [setWrapperClasses description]
     * \@method setWrapperClasses
     * @param {?} value
     * @return {?}
     */
    setWrapperClasses(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { wrapperClasses: value }));
    }
    /**
     * [setWindowInnerHeight description]
     * \@method setWindowInnerHeight
     * @param {?} value
     * @return {?}
     */
    setWindowInnerHeight(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { windowInnerHeight: value }));
    }
    /**
     * [setWindowInnerWidth description]
     * \@method setWindowInnerWidth
     * @param {?} value
     * @return {?}
     */
    setWindowInnerWidth(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { windowInnerWidth: value }));
    }
}

class SidebarRightService {
    /**
     * [offsetHeight description]
     * \@method offsetHeight
     * @return {?}
     */
    get offsetHeight() {
        return this.elementRef ? this.elementRef.nativeElement.offsetHeight : null;
    }
    /**
     * [scrollHeight description]
     * \@method scrollHeight
     * @return {?}
     */
    get scrollHeight() {
        return this.elementRef ? this.elementRef.nativeElement.scrollHeight : null;
    }
}
SidebarRightService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
SidebarRightService.ctorParameters = () => [];

class HeaderService {
    /**
     * [offsetHeight description]
     * \@method offsetHeight
     * @return {?}
     */
    get offsetHeight() {
        return this.elementRef.nativeElement.offsetHeight;
    }
}
HeaderService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
HeaderService.ctorParameters = () => [];

class FooterService {
    /**
     * [offsetHeight description]
     * \@method offsetHeight
     * @return {?}
     */
    get offsetHeight() {
        return this.elementRef.nativeElement.offsetHeight;
    }
}
FooterService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
FooterService.ctorParameters = () => [];

/**
 * [throttle description]
 * \@method throttle
 * @param {?} callback
 * @param {?} delay
 * @return {?}
 */
function throttle(callback, delay) {
    let /** @type {?} */ timeout = null;
    return (...args) => {
        if (!timeout) {
            timeout = setTimeout(() => {
                callback.call(this, ...args);
                timeout = null;
            }, delay);
        }
    };
}
/**
 * [removeSubscriptions description]
 * \@method removeSubscriptions
 * @param {?} subscriptions
 * @return {?}
 */
function removeSubscriptions(subscriptions) {
    if (subscriptions) {
        subscriptions.forEach((subscription) => {
            subscription.unsubscribe();
        });
    }
    return [];
}
/**
 * [removeListeners description]
 * \@method removeListeners
 * @param {?} listeners
 * @return {?}
 */
function removeListeners(listeners) {
    if (listeners) {
        listeners.forEach((listener) => {
            listener();
        });
    }
    return [];
}

class ContentComponent {
    /**
     * \@method constructor
     * @param {?} layoutStore
     * @param {?} routingService
     * @param {?} titleService
     * @param {?} elementRef
     * @param {?} changeDetectorRef
     * @param {?} sidebarRightService
     * @param {?} headerService
     * @param {?} footerService
     * @param {?} router
     */
    constructor(layoutStore, routingService, titleService, elementRef, changeDetectorRef, sidebarRightService, headerService, footerService, router$$1) {
        this.layoutStore = layoutStore;
        this.routingService = routingService;
        this.titleService = titleService;
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.sidebarRightService = sidebarRightService;
        this.headerService = headerService;
        this.footerService = footerService;
        this.router = router$$1;
        this.subscriptions = [];
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.titleTag = this.titleService.getTitle();
        this.subscriptions.push(this.routingService.onChange.subscribe((value) => {
            if (value && value[value.length - 1]) {
                this.titleService.setTitle(this.getTitle(value[value.length - 1].data['title']));
                this.header = value[value.length - 1].data['title'];
                this.description = value[value.length - 1].data['description'];
            }
            this.changeDetectorRef.markForCheck();
        }));
        this.subscriptions.push(this.router.events.subscribe((routeEvent) => {
            if (routeEvent instanceof NavigationStart) {
                this.navigationEnd = false;
            }
            if (routeEvent instanceof NavigationEnd) {
                this.navigationEnd = true;
                this.setContentMinHeight();
            }
        }));
        this.subscriptions.push(this.layoutStore.sidebarLeftElementHeight.subscribe((value) => {
            this.sidebarLeftHeight = value;
            this.setContentMinHeight();
        }));
        this.subscriptions.push(this.layoutStore.layout.subscribe((value) => {
            this.layout = value;
            this.setContentMinHeight();
        }));
        this.subscriptions.push(this.layoutStore.windowInnerHeight.subscribe((value) => {
            this.windowInnerHeight = value;
            this.setContentMinHeight();
        }));
        this.heightStyle = this.windowInnerHeight;
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions = removeSubscriptions(this.subscriptions);
    }
    /**
     * [scrollHeight description]
     * \@method scrollHeight
     * @return {?}
     */
    get scrollHeight() {
        return this.contentInnerElement.nativeElement.scrollHeight;
    }
    /**
     * [getTitle description]
     * \@method getTitle
     * @param {?} title
     * @return {?}
     */
    getTitle(title) {
        return title ? `${title} - ${this.titleTag}` : this.titleTag;
    }
    /**
     * [setMinHeight description]
     * \@method setMinHeight
     * @return {?}
     */
    setContentMinHeight() {
        if (this.navigationEnd) {
            let /** @type {?} */ heightStyle, /** @type {?} */ headerFooterOffsetHeight = this.headerService.offsetHeight + this.footerService.offsetHeight;
            if (this.layout === 'fixed') {
                heightStyle = this.windowInnerHeight - this.footerService.offsetHeight;
            }
            else {
                let /** @type {?} */ sidebarRight = this.sidebarRightService.scrollHeight ? this.sidebarRightService.scrollHeight - this.headerService.offsetHeight : 0;
                heightStyle = Math.max(this.windowInnerHeight - headerFooterOffsetHeight, this.sidebarLeftHeight - this.headerService.offsetHeight, sidebarRight);
            }
            if (heightStyle && heightStyle !== this.heightStyle) {
                if (this.scrollHeight > heightStyle) {
                    heightStyle = null;
                }
                this.heightStyle = heightStyle;
                this.changeDetectorRef.detectChanges();
            }
        }
    }
}
ContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-content',
                template: `
    <div class="content-wrapper" [style.min-height.px]="heightStyle">
      <div #contentInnerElement class="content-inner">
        <ng-content select="[mk-layout-content-before-header]"></ng-content>
        <section *ngIf="header || description" class="content-header">
          <h1>
            {{header}}
            <small *ngIf="description">{{description}}</small>
          </h1>
          <mk-breadcrumbs></mk-breadcrumbs>
        </section>
        <ng-content select="[mk-layout-content-after-header]"></ng-content>
        <section class="content">
          <ng-content></ng-content>
        </section>
      </div>
    </div>
  `,
                styles: [`
    :host {
      display: block;
    }

    .content-wrapper {
         position: relative;
    }
  `],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
ContentComponent.ctorParameters = () => [
    { type: LayoutStore, },
    { type: RoutingService, },
    { type: Title, },
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
    { type: SidebarRightService, },
    { type: HeaderService, },
    { type: FooterService, },
    { type: Router, },
];
ContentComponent.propDecorators = {
    'contentInnerElement': [{ type: ViewChild, args: ['contentInnerElement',] },],
};

class ContentModule {
}
ContentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule, BreadcrumbsModule],
                exports: [ContentComponent],
                declarations: [ContentComponent]
            },] },
];
/**
 * @nocollapse
 */
ContentModule.ctorParameters = () => [];

/**
 * Footer Left
 */
class FooterLeftComponent {
}
FooterLeftComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-footer-left',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            },] },
];
/**
 * @nocollapse
 */
FooterLeftComponent.ctorParameters = () => [];
FooterLeftComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
/**
 * Footer Right
 */
class FooterRightComponent {
}
FooterRightComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-footer-right',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            },] },
];
/**
 * @nocollapse
 */
FooterRightComponent.ctorParameters = () => [];
FooterRightComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
class FooterComponent {
    /**
     * @param {?} elementRef
     * @param {?} footerService
     */
    constructor(elementRef, footerService) {
        this.elementRef = elementRef;
        this.footerService = footerService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.footerService.elementRef = this.elementRef;
    }
}
FooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-footer',
                template: `
    <footer class="main-footer">
      <div class="pull-right hidden-xs">
        <ng-template [ngTemplateOutlet]="footerRightComponent?.templateRef"></ng-template>
      </div>
      <ng-template [ngTemplateOutlet]="footerLeftComponent?.templateRef"></ng-template>
    </footer>
  `,
                styles: [`
    :host {
      display: block;
    }
  `]
            },] },
];
/**
 * @nocollapse
 */
FooterComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: FooterService, },
];
FooterComponent.propDecorators = {
    'footerLeftComponent': [{ type: ContentChild, args: [FooterLeftComponent,] },],
    'footerRightComponent': [{ type: ContentChild, args: [FooterRightComponent,] },],
};

class FooterModule {
}
FooterModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [FooterComponent, FooterLeftComponent, FooterRightComponent],
                declarations: [FooterComponent, FooterLeftComponent, FooterRightComponent]
            },] },
];
/**
 * @nocollapse
 */
FooterModule.ctorParameters = () => [];

/**
 * Header Logo
 */
class HeaderLogoComponent {
}
HeaderLogoComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-header-logo',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            },] },
];
/**
 * @nocollapse
 */
HeaderLogoComponent.ctorParameters = () => [];
HeaderLogoComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
/**
 * Header Logo Mini
 */
class HeaderLogoMiniComponent {
}
HeaderLogoMiniComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-header-logo-mini',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            },] },
];
/**
 * @nocollapse
 */
HeaderLogoMiniComponent.ctorParameters = () => [];
HeaderLogoMiniComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
/**
 * Header
 */
class HeaderComponent {
    /**
     * \@method constructor
     * @param {?} layoutStore
     * @param {?} ngZone
     * @param {?} renderer2
     * @param {?} elementRef
     * @param {?} headerService
     */
    constructor(layoutStore, ngZone, renderer2, elementRef, headerService) {
        this.layoutStore = layoutStore;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.elementRef = elementRef;
        this.headerService = headerService;
        this.listeners = [];
        this.subscriptions = [];
        this.isSidebarLeftToggle = true;
        this.isSidebarRightToggle = true;
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.headerService.elementRef = this.headerElement;
        if (this.sidebarLeftToggleElement) {
            this.subscriptions.push(this.layoutStore.isSidebarLeftCollapsed.subscribe((value) => {
                this.isSidebarLeftCollapsed = value;
            }));
            this.ngZone.runOutsideAngular(() => {
                this.listeners.push(this.renderer2.listen(this.sidebarLeftToggleElement.nativeElement, 'click', (event) => {
                    event.preventDefault();
                    this.layoutStore.sidebarLeftCollapsed(!this.isSidebarLeftCollapsed);
                }));
            });
        }
        if (this.sidebarRightToggleElement) {
            this.subscriptions.push(this.layoutStore.isSidebarRightCollapsed.subscribe((value) => {
                this.isSidebarRightCollapsed = value;
            }));
            this.ngZone.runOutsideAngular(() => {
                this.listeners.push(this.renderer2.listen(this.sidebarRightToggleElement.nativeElement, 'click', (event) => {
                    event.preventDefault();
                    this.layoutStore.sidebarRightCollapsed(!this.isSidebarRightCollapsed);
                }));
            });
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.listeners = removeListeners(this.listeners);
        this.subscriptions = removeSubscriptions(this.subscriptions);
    }
}
HeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-header',
                template: `
    <header #headerElement class="main-header">
      <a href="/" class="logo">
        <span class="logo-mini"><ng-template [ngTemplateOutlet]="headerLogoMiniComponent?.templateRef"></ng-template></span>
        <span class="logo-lg"><ng-template [ngTemplateOutlet]="headerLogoComponent?.templateRef"></ng-template></span>
      </a>
      <nav *ngIf="isSidebarLeftToggle" class="navbar navbar-static-top">
        <a #sidebarLeftToggleElement href="#" class="sidebar-toggle">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
        <div *ngIf="isSidebarRightToggle" class="sidebar-right-toggle">
          <a #sidebarRightToggleElement href="#"><i class="fa fa-gears"></i></a>
        </div>
        <ng-content></ng-content>
      </nav>
    </header>
  `,
                styles: [`
    :host {
      display: block;
    }

    .sidebar-right-toggle {
      float: right;
    }

    .sidebar-right-toggle a {
      padding: 15px;
      display: block;
      line-height: 20px;
      cursor: pointer;
    }
  `]
            },] },
];
/**
 * @nocollapse
 */
HeaderComponent.ctorParameters = () => [
    { type: LayoutStore, },
    { type: NgZone, },
    { type: Renderer2, },
    { type: ElementRef, },
    { type: HeaderService, },
];
HeaderComponent.propDecorators = {
    'isSidebarLeftToggle': [{ type: Input },],
    'isSidebarRightToggle': [{ type: Input },],
    'headerLogoComponent': [{ type: ContentChild, args: [HeaderLogoComponent,] },],
    'headerLogoMiniComponent': [{ type: ContentChild, args: [HeaderLogoMiniComponent,] },],
    'headerElement': [{ type: ViewChild, args: ['headerElement',] },],
    'sidebarLeftToggleElement': [{ type: ViewChild, args: ['sidebarLeftToggleElement',] },],
    'sidebarRightToggleElement': [{ type: ViewChild, args: ['sidebarRightToggleElement',] },],
};

class HeaderModule {
}
HeaderModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [HeaderComponent, HeaderLogoComponent, HeaderLogoMiniComponent],
                declarations: [HeaderComponent, HeaderLogoComponent, HeaderLogoMiniComponent]
            },] },
];
/**
 * @nocollapse
 */
HeaderModule.ctorParameters = () => [];

class CollapseAnimationDirective {
    /**
     * \@method constructor
     * @param {?} elementRef
     * @param {?} ngZone
     * @param {?} renderer2
     */
    constructor(elementRef, ngZone, renderer2) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.firstStart = true;
        this.collapseAnimationDuration = 350;
        this.startEventEmitter = new EventEmitter();
        this.doneEventEmitter = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _isCollapsed(value) {
        this.lastIsCollapsed = this.isCollapsed;
        this.isCollapsed = value;
        if (!this.firstStart) {
            this.emit('start');
            if (value) {
                this.collapse();
            }
            else if (value === false) {
                this.unCollapse();
            }
        }
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        if (this.collapseAnimationDuration && this.collapseAnimationDuration !== 350) {
            this.renderer2.setStyle(this.elementRef.nativeElement, 'transition-duration', `${this.collapseAnimationDuration}ms`);
        }
        if (this.collapseAnimationTiming) {
            this.renderer2.setStyle(this.elementRef.nativeElement, 'transition-timing-function', this.collapseAnimationTiming);
        }
    }
    /**
     * \@method ngAfterContentInit
     * @return {?}
     */
    ngAfterContentInit() {
        this.emit('start');
        if (this.isCollapsed) {
            this.renderer2.setStyle(this.elementRef.nativeElement, 'display', 'none');
            this.renderer2.addClass(this.elementRef.nativeElement, 'collapsing');
        }
        this.emit('done');
        this.firstStart = false;
        this.subscriptions();
    }
    /**
     * [ngOnDestroy description]
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        if (this.listener) {
            this.listener();
        }
    }
    /**
     * [subscriptions description]
     * \@method subscriptions
     * @return {?}
     */
    subscriptions() {
        this.ngZone.runOutsideAngular(() => {
            this.listener = this.renderer2.listen(this.elementRef.nativeElement, 'transitionend', () => {
                if (!this.isCollapsed) {
                    this.renderer2.removeClass(this.elementRef.nativeElement, 'un-collapse');
                    this.renderer2.removeClass(this.elementRef.nativeElement, 'collapsing');
                }
                else {
                    this.renderer2.setStyle(this.elementRef.nativeElement, 'display', 'none');
                }
                requestAnimationFrame(() => {
                    this.renderer2.removeStyle(this.elementRef.nativeElement, 'height');
                    this.emit('done');
                    this.transitioning = false;
                });
            });
        });
    }
    /**
     * [unCollapse description]
     * \@method unCollapse
     * @return {?}
     */
    unCollapse() {
        this.transitioning = true;
        this.renderer2.addClass(this.elementRef.nativeElement, 'un-collapse');
        this.renderer2.removeStyle(this.elementRef.nativeElement, 'display');
        this.renderer2.setStyle(this.elementRef.nativeElement, 'height', `${this.elementRef.nativeElement.scrollHeight}px`);
    }
    /**
     * [collapse description]
     * \@method collapse
     * @return {?}
     */
    collapse() {
        requestAnimationFrame(() => {
            if (!this.transitioning) {
                this.renderer2.setStyle(this.elementRef.nativeElement, 'height', `${this.elementRef.nativeElement.offsetHeight}px`);
                this.renderer2.addClass(this.elementRef.nativeElement, 'collapsing');
            }
            this.transitioning = true;
            requestAnimationFrame(() => {
                this.renderer2.setStyle(this.elementRef.nativeElement, 'height', `0px`);
            });
        });
    }
    /**
     * @param {?} phaseName
     * @return {?}
     */
    emit(phaseName) {
        let /** @type {?} */ event = {
            element: this.elementRef.nativeElement,
            fromState: this.lastIsCollapsed === undefined ? 'void' : this.lastIsCollapsed ? '1' : '0',
            phaseName: phaseName,
            toState: this.isCollapsed === undefined ? 'void' : this.isCollapsed ? '1' : '0',
            totalTime: this.collapseAnimationDuration,
            triggerName: 'collapseAnimation'
        };
        if (phaseName === 'done') {
            this.doneEventEmitter.emit(event);
        }
        else if (phaseName === 'start') {
            this.startEventEmitter.emit(event);
        }
    }
}
CollapseAnimationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[collapseAnimation]'
            },] },
];
/**
 * @nocollapse
 */
CollapseAnimationDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
    { type: Renderer2, },
];
CollapseAnimationDirective.propDecorators = {
    'collapseAnimationDuration': [{ type: Input },],
    'collapseAnimationTiming': [{ type: Input },],
    '_isCollapsed': [{ type: Input, args: ['collapseAnimation',] },],
    'startEventEmitter': [{ type: Output, args: ['collapseAnimation.start',] },],
    'doneEventEmitter': [{ type: Output, args: ['collapseAnimation.done',] },],
};

class AnimationsModule {
}
AnimationsModule.decorators = [
    { type: NgModule, args: [{
                exports: [CollapseAnimationDirective],
                declarations: [CollapseAnimationDirective]
            },] },
];
/**
 * @nocollapse
 */
AnimationsModule.ctorParameters = () => [];

class SidebarLeftToggleDirective {
    /**
     * \@method constructor
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
SidebarLeftToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkMenuToggle]'
            },] },
];
/**
 * @nocollapse
 */
SidebarLeftToggleDirective.ctorParameters = () => [
    { type: ElementRef, },
];
SidebarLeftToggleDirective.propDecorators = {
    'item': [{ type: Input, args: ['mkMenuToggle',] },],
};

class WrapperService {
}
WrapperService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
WrapperService.ctorParameters = () => [];

class SidebarLeftComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef
     * @param {?} layoutStore
     * @param {?} ngZone
     * @param {?} renderer2
     * @param {?} router
     * @param {?} routingService
     * @param {?} wrapperService
     * @param {?} headerService
     */
    constructor(changeDetectorRef, layoutStore, ngZone, renderer2, router$$1, routingService, wrapperService, headerService) {
        this.changeDetectorRef = changeDetectorRef;
        this.layoutStore = layoutStore;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.router = router$$1;
        this.routingService = routingService;
        this.wrapperService = wrapperService;
        this.headerService = headerService;
        this.collapsedItems = [];
        this.activatedItems = [];
        this.toggleListeners = [];
        this.listeners = [];
        this.itemsByIds = {};
        this.runningAnimations = 0;
        this.subscriptions = [];
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.layoutStore.sidebarLeftMenu.subscribe(value => {
            this.menu = value;
            this.monkeyPatchMenu(this.menu);
        }));
        this.subscriptions.push(this.routingService.events.subscribe((event) => {
            if (event instanceof NavigationEnd) {
                this.setMenuListeners(event.url);
            }
        }));
        this.setSidebarListeners();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.setMenuTogglesListeners();
        this.checkMenuWithoutChildren();
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions = removeSubscriptions(this.subscriptions);
        this.listeners = removeListeners(this.listeners);
        this.toggleListeners = removeListeners(this.toggleListeners);
    }
    /**
     * [setSidebarListeners description]
     * \@method setSidebarListeners
     * @return {?}
     */
    setSidebarListeners() {
        this.subscriptions.push(this.layoutStore.layout.subscribe((value) => {
            this.layout = value;
            this.setSidebarHeight();
        }));
        this.subscriptions.push(this.layoutStore.windowInnerHeight.subscribe((value) => {
            this.windowInnerHeight = value;
            this.setSidebarHeight();
        }));
        this.subscriptions.push(this.layoutStore.sidebarLeftMenu.subscribe((value) => {
            this.changeDetectorRef.detectChanges();
        }));
        this.ngZone.runOutsideAngular(() => {
            this.listeners.push(this.renderer2.listen(this.sidebarElement.nativeElement, 'mouseenter', (event) => {
                this.layoutStore.sidebarLeftMouseOver(true);
            }));
            this.listeners.push(this.renderer2.listen(this.sidebarElement.nativeElement, 'mouseleave', (event) => {
                this.layoutStore.sidebarLeftMouseOver(false);
            }));
        });
        this.subscriptions.push(this.layoutStore.windowInnerWidth.subscribe((value) => {
            this.windowInnerWidth = value;
            if (!this.isSidebarLeftCollapsed && this.windowInnerWidth <= 767) {
                this.layoutStore.sidebarLeftCollapsed(true);
            }
            else if (this.windowInnerWidth > 767 && this.isSidebarLeftCollapsed && !this.isSidebarLeftExpandOnOver) {
                this.layoutStore.sidebarLeftCollapsed(false);
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarLeftMouseOver.subscribe((value) => {
            this.isSidebarLeftMouseOver = value;
            if (this.isSidebarLeftExpandOnOver) {
                this.layoutStore.sidebarLeftCollapsed(!value);
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarLeftExpandOnOver.subscribe((value) => {
            this.isSidebarLeftExpandOnOver = value;
            if (this.windowInnerWidth > 767 && this.isSidebarLeftCollapsed !== undefined) {
                this.layoutStore.sidebarLeftCollapsed(value);
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarLeftCollapsed.subscribe((value) => {
            this.isSidebarLeftCollapsed = value;
            if (this.windowInnerWidth <= 767) {
                if (value) {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-open');
                }
                else {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-open');
                }
            }
            else {
                if (this.isSidebarLeftExpandOnOver && !this.isSidebarLeftMouseOver && !value) {
                    this.layoutStore.sidebarLeftExpandOnOver(false);
                }
                if (value) {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-collapse');
                    if (this.isSidebarLeftExpandOnOver) {
                        this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-expanded-on-hover');
                    }
                }
                else {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-collapse');
                    if (this.isSidebarLeftExpandOnOver) {
                        this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-expanded-on-hover');
                    }
                }
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarLeftMini.subscribe((value) => {
            if (value) {
                this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-mini');
            }
            else {
                this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-mini');
            }
        }));
    }
    /**
     * [setMenuListeners description]
     * \@method setMenuListeners
     * @param {?} url
     * @return {?}
     */
    setMenuListeners(url) {
        if (url === '/') {
            this.activeItems(url);
            this.changeDetectorRef.detectChanges();
        }
        else {
            let /** @type {?} */ primaryOutlet = this.router.parseUrl(url).root.children[PRIMARY_OUTLET];
            if (primaryOutlet) {
                this.activeItems(primaryOutlet.toString());
                this.changeDetectorRef.detectChanges();
            }
        }
        if (this.windowInnerWidth <= 767 || this.isSidebarLeftExpandOnOver) {
            this.layoutStore.sidebarLeftCollapsed(true);
        }
    }
    /**
     * [getIconClasses description]
     * \@method getIconClasses
     * @param {?} item
     * @return {?}
     */
    getIconClasses(item) {
        if (item.iconClasses || item.iconClasses === '') {
            return item.iconClasses;
        }
        else {
            return 'fa fa-circle-o';
        }
    }
    /**
     * [visibilityStateStart description]
     * \@method visibilityStateStart
     * @param {?} event
     * @return {?}
     */
    visibilityStateStart(event) {
        this.runningAnimations++;
        this.ngZone.runOutsideAngular(() => {
            setTimeout(() => {
                this.runningAnimations--;
                if (!this.runningAnimations) {
                    this.layoutStore.setSidebarLeftElementHeight(this.sidebarElement.nativeElement.offsetHeight);
                }
            }, event.totalTime);
        });
    }
    /**
     * [uncollapseItemParents description]
     * \@method uncollapseItemParents
     * @param {?} item
     * @param {?=} isActive
     * @return {?}
     */
    uncollapseItemParents(item, isActive = false) {
        if (isActive) {
            item.isActive = true;
        }
        item.isCollapsed = false;
        this.collapsedItems.push(item);
        if (item.parentId) {
            this.uncollapseItemParents(this.itemsByIds[item.parentId], isActive);
        }
    }
    /**
     * [findItemsByUrl description]
     * \@method findItemsByUrl
     * @param {?} url
     * @param {?} items
     * @param {?=} returnItems
     * @return {?}
     */
    findItemsByUrl(url, items, returnItems = []) {
        items.forEach((item) => {
            if (item.route === url) {
                returnItems.push(item);
            }
            else if (item.children) {
                this.findItemsByUrl(url, item.children, returnItems);
            }
        });
        return returnItems;
    }
    /**
     * [activeItems description]
     * \@method activeItems
     * @param {?} url
     * @return {?}
     */
    activeItems(url) {
        this.activatedItems.forEach((item) => {
            item.isActive = false;
        });
        this.activatedItems = [];
        this.collapsedItems.forEach((item) => {
            item.isActive = false;
            item.isCollapsed = true;
        });
        this.collapsedItems = [];
        let /** @type {?} */ items = this.findItemsByUrl(url, this.menu);
        items.forEach(item => {
            item.isActive = true;
            this.uncollapseItemParents(item, true);
            this.activatedItems.push(item);
        });
    }
    /**
     * [monkeyPatchMenu description]
     * \@method monkeyPatchMenu
     * @param {?} items
     * @param {?=} parentId
     * @return {?}
     */
    monkeyPatchMenu(items, parentId) {
        items.forEach((item, index) => {
            item.id = parentId ? Number(parentId + '' + index) : index;
            if (parentId) {
                item.parentId = parentId;
            }
            item.isCollapsed = true;
            item.isActive = false;
            if (parentId || item.children) {
                this.itemsByIds[item.id] = item;
            }
            if (item.children) {
                this.monkeyPatchMenu(item.children, item.id);
            }
        });
    }
    /**
     * [setMenuTogglesListeners description]
     * \@method setMenuTogglesListeners
     * @return {?}
     */
    setMenuTogglesListeners() {
        this.toggleListeners = removeListeners(this.toggleListeners);
        this.ngZone.runOutsideAngular(() => {
            this.sidebarLeftToggleDirectives.forEach((menuToggle) => {
                this.toggleListeners.push(this.renderer2.listen(menuToggle.elementRef.nativeElement, 'click', (event) => {
                    event.preventDefault();
                    if (menuToggle.item.isCollapsed) {
                        this.collapsedItems.forEach((item) => {
                            item.isCollapsed = true;
                        });
                        this.collapsedItems = [];
                        this.uncollapseItemParents(menuToggle.item);
                    }
                    else {
                        menuToggle.item.isCollapsed = !menuToggle.item.isCollapsed;
                    }
                    this.changeDetectorRef.detectChanges();
                }));
            });
        });
    }
    /**
     * [checkMenuWithoutChildren description]
     * \@method checkMenuWithoutChildren
     * @return {?}
     */
    checkMenuWithoutChildren() {
        let /** @type {?} */ menuHaveChildren;
        this.menu.forEach((item) => {
            if (item.children) {
                return menuHaveChildren = true;
            }
        });
        if (!menuHaveChildren) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.layoutStore.setSidebarLeftElementHeight(this.sidebarElement.nativeElement.offsetHeight);
                });
            });
        }
    }
    /**
     * [setSidebarHeight description]
     * \@method setSidebarHeight
     * @return {?}
     */
    setSidebarHeight() {
        if (this.layout === 'fixed') {
            let /** @type {?} */ height = this.windowInnerHeight - this.headerService.offsetHeight;
            if (height && height !== this.sidebarHeight) {
                this.sidebarHeight = height;
                this.sidebarOverflow = 'auto';
                this.changeDetectorRef.detectChanges();
            }
        }
        else if (this.sidebarHeight) {
            this.sidebarOverflow = this.sidebarHeight = null;
            this.changeDetectorRef.detectChanges();
        }
    }
}
SidebarLeftComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-sidebar-left',
                template: `
    <aside class="main-sidebar">
      <section class="sidebar" #sidebarElement [style.height.px]="sidebarHeight" [style.overflow]="sidebarOverflow">
        <ng-content></ng-content>
      	<ul class="sidebar-menu">
          <ng-container *ngFor="let item of menu">
            <ng-container *ngTemplateOutlet="sidebarInner; context: {item: item}"></ng-container>
          </ng-container>
      	</ul>
      </section>
    </aside>

    <ng-template #sidebarInner let-item="item">
      <li [class.active]="item.isActive" [class.header]="item.separator" [class.menu-open]="!item.isCollapsed">
        <span *ngIf="item.separator">{{item.label}}</span>
        <a *ngIf="!item.separator && item.route" [routerLink]="item.route">
        	<i [class]="getIconClasses(item)"></i><span>{{item.label}}</span>
        	<span *ngIf="item.children || item.pullRights" class="pull-right-container">
        		<span *ngFor="let rightItem of item.pullRights" class="pull-right {{rightItem.classes}}">{{rightItem.text}}</span>
        	  <i *ngIf="!item.pullRights" class="fa fa-angle-left pull-right"></i>
        	</span>
        </a>
        <a *ngIf="!item.separator && !item.route" href="#" [mkMenuToggle]="item">
        	<i [class]="getIconClasses(item)"></i><span>{{item.label}}</span>
        	<span *ngIf="item.children || item.pullRights" class="pull-right-container">
        		<span *ngFor="let rightItem of item.pullRights" class="pull-right {{rightItem.classes}}">{{rightItem.text}}</span>
        	  <i *ngIf="!item.pullRights" class="fa fa-angle-left pull-right"></i>
        	</span>
        </a>
        <ul *ngIf="item.children" [collapseAnimation]="item.isCollapsed" (collapseAnimation.start)="visibilityStateStart($event)" class="treeview-menu">
          <ng-container *ngFor="let item of item.children">
            <ng-container *ngTemplateOutlet="sidebarInner; context: {item: item}"></ng-container>
          </ng-container>
        </ul>
      </li>
    </ng-template>
  `,
                styles: [`
    .main-sidebar {
      overflow: hidden;
    }

    .treeview-menu.collapse {
      display: none;
    }

    .treeview-menu,
    .treeview-menu.collapse.in {
      display: block;
    }
  `],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
SidebarLeftComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: LayoutStore, },
    { type: NgZone, },
    { type: Renderer2, },
    { type: Router, },
    { type: RoutingService, },
    { type: WrapperService, },
    { type: HeaderService, },
];
SidebarLeftComponent.propDecorators = {
    'sidebarElement': [{ type: ViewChild, args: ['sidebarElement',] },],
    'sidebarLeftToggleDirectives': [{ type: ViewChildren, args: [SidebarLeftToggleDirective,] },],
};

class SidebarLeftModule {
}
SidebarLeftModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule, AnimationsModule],
                exports: [SidebarLeftComponent],
                declarations: [SidebarLeftToggleDirective, SidebarLeftComponent]
            },] },
];
/**
 * @nocollapse
 */
SidebarLeftModule.ctorParameters = () => [];

class SidebarRightComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer2
     * @param {?} layoutStore
     * @param {?} sidebarRightService
     * @param {?} wrapperService
     */
    constructor(elementRef, renderer2, layoutStore, sidebarRightService, wrapperService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.layoutStore = layoutStore;
        this.sidebarRightService = sidebarRightService;
        this.wrapperService = wrapperService;
        this.listeners = [];
        this.subscriptions = [];
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.renderer2.addClass(this.elementRef.nativeElement, 'control-sidebar');
        this.subscriptions.push(this.layoutStore.isSidebarRightCollapsed.subscribe(value => {
            this.isSidebarRightCollapsed = value;
            if (!value) {
                this.renderer2.addClass(this.elementRef.nativeElement, 'control-sidebar-open');
                if (!this.isSidebarRightOverContent) {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
            }
            else {
                this.renderer2.removeClass(this.elementRef.nativeElement, 'control-sidebar-open');
                if (!this.isSidebarRightOverContent) {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarRightOverContent.subscribe((value) => {
            this.isSidebarRightOverContent = value;
            if (!this.isSidebarRightCollapsed) {
                if (value) {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
                else {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
            }
        }));
        this.subscriptions.push(this.layoutStore.sidebarRightSkin.subscribe((value) => {
            if (this.skin !== value) {
                this.renderer2.removeClass(this.elementRef.nativeElement, `control-sidebar-${this.skin}`);
            }
            this.skin = value;
            this.renderer2.addClass(this.elementRef.nativeElement, `control-sidebar-${value}`);
        }));
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.sidebarRightService.elementRef = this.sidebarContentElement;
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.listeners = removeListeners(this.listeners);
        this.subscriptions = removeSubscriptions(this.subscriptions);
    }
}
SidebarRightComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-sidebar-right',
                template: `
    <div #sidebarContentElement class="control-sidebar-content">
      <ng-content></ng-content>
    </div>
    <div class="control-sidebar-bg"></div>
  `,
                styles: [`
    :host {
      display: block;
      height: 100%;
    }

    .control-sidebar-bg {
      z-index: -1;
    }

    /deep/ .tab-content {
      padding: 10px 15px;
    }
  `],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
SidebarRightComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: LayoutStore, },
    { type: SidebarRightService, },
    { type: WrapperService, },
];
SidebarRightComponent.propDecorators = {
    'sidebarContentElement': [{ type: ViewChild, args: ['sidebarContentElement',] },],
};

class SidebarRightModule {
}
SidebarRightModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [SidebarRightComponent],
                declarations: [SidebarRightComponent]
            },] },
];
/**
 * @nocollapse
 */
SidebarRightModule.ctorParameters = () => [];

class WrapperComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer2
     * @param {?} layoutStore
     * @param {?} wrapperService
     * @param {?} ngZone
     */
    constructor(elementRef, renderer2, layoutStore, wrapperService, ngZone) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.layoutStore = layoutStore;
        this.wrapperService = wrapperService;
        this.ngZone = ngZone;
        this.listeners = [];
        this.subscriptions = [];
    }
    /**
     * [ngOnInit description]
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.layoutStore.setWindowInnerHeight(window.innerHeight);
        this.layoutStore.setWindowInnerWidth(window.innerWidth);
        this.wrapperService.wrapperElementRef = this.elementRef;
        this.subscriptions.push(this.layoutStore.wrapperClasses.subscribe((value) => {
            this.classes = value ? value : null;
        }));
        this.ngZone.runOutsideAngular(() => {
            this.listeners.push(this.renderer2.listen('window', 'resize', throttle(() => {
                this.layoutStore.setWindowInnerHeight(window.innerHeight);
                this.layoutStore.setWindowInnerWidth(window.innerWidth);
            }, 250)));
        });
        this.subscriptions.push(this.layoutStore.layout.subscribe((value) => {
            value === 'fixed' ? this.renderer2.addClass(this.elementRef.nativeElement, 'fixed') : this.renderer2.removeClass(this.elementRef.nativeElement, 'fixed');
            value === 'boxed' ? this.renderer2.addClass(this.elementRef.nativeElement, 'layout-boxed') : this.renderer2.removeClass(this.elementRef.nativeElement, 'layout-boxed');
        }));
        this.subscriptions.push(this.layoutStore.skin.subscribe((value) => {
            if (value) {
                if (this.skin && this.skin !== value) {
                    this.renderer2.removeClass(this.elementRef.nativeElement, `skin-${this.skin}`);
                }
                this.skin = value;
                this.renderer2.addClass(this.elementRef.nativeElement, `skin-${this.skin}`);
            }
        }));
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions = removeSubscriptions(this.subscriptions);
        this.listeners = removeListeners(this.listeners);
    }
}
WrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-wrapper',
                template: `
    <div class="wrapper" [ngClass]="classes">
      <ng-content></ng-content>
    </div>
  `,
                styles: [`
    :host {
      display: block;
    }

    :host /deep/ .sidebar-right-toggle > a {
      color: #fff;
    }

    :host /deep/ .sidebar-right-toggle > a:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    :host.skin-black /deep/ .sidebar-right-toggle > a,
    :host.skin-black-light /deep/ .sidebar-right-toggle > a {
      color: #333;
      border-right-width: 0;
    }

    :host.skin-black /deep/ .sidebar-right-toggle > a:hover,
    :host.skin-black-light /deep/ .sidebar-right-toggle > a:hover {
      background-color: #fff;
      color: #999;
    }

    :host.skin-black /deep/ .sidebar-right-toggle > a {
      border-left: 1px solid #eee;
    }

    :host.skin-black-light /deep/ .sidebar-right-toggle > a {
      border-left: 1px solid #d2d6de;
    }
  `]
            },] },
];
/**
 * @nocollapse
 */
WrapperComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: LayoutStore, },
    { type: WrapperService, },
    { type: NgZone, },
];

class WrapperModule {
}
WrapperModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [WrapperComponent],
                declarations: [WrapperComponent]
            },] },
];
/**
 * @nocollapse
 */
WrapperModule.ctorParameters = () => [];

class LayoutService {
    /**
     * \@method constructor
     * @param {?} routingService
     */
    constructor(routingService) {
        this.routingService = routingService;
        this.isCustomLayout = new BehaviorSubject$1(true);
        this.init();
    }
    /**
     * [init description]
     * \@method init
     * @return {?}
     */
    init() {
        this.routingService.onChange.subscribe((value) => {
            if (value && value[value.length - 1]) {
                if (this.customLayout === undefined || this.customLayout !== value[value.length - 1].data['disableLayout']) {
                    this.isCustomLayout.next(!!value[value.length - 1].data['customLayout']);
                }
                this.customLayout = value[value.length - 1].data['customLayout'];
            }
        });
    }
}
LayoutService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
LayoutService.ctorParameters = () => [
    { type: RoutingService, },
];

/**
 * [InjectionToken description]
 */
const LayoutConfigToken = new InjectionToken('layoutConfig');
/**
 * [layoutStoreFactory description]
 * @param {?} layoutConfig
 * @return {?}
 */
function layoutStoreFactory(layoutConfig) {
    return new LayoutStore(layoutConfig);
}
/**
 * [layoutProviders description]
 * @param {?} layoutConfig
 * @return {?}
 */
function layoutProvider(layoutConfig) {
    return [{
            provide: LayoutStore,
            useFactory: layoutStoreFactory,
            deps: [LayoutConfigToken]
        }, {
            provide: LayoutConfigToken,
            useValue: layoutConfig
        }
    ];
}

class LayoutModule {
    /**
     * \@method constructor
     * @param {?} parentModule
     */
    constructor(parentModule) {
        if (parentModule) {
            throw new Error('LayoutModule is already loaded. Import it in the AppModule only!');
        }
    }
    /**
     * [forRoot description]
     * \@method forRoot
     * @param {?} layoutConfig
     * @return {?}
     */
    static forRoot(layoutConfig) {
        return {
            ngModule: LayoutModule,
            providers: [...layoutProvider(layoutConfig), LayoutService]
        };
    }
}
LayoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule],
                exports: [ContentModule, FooterModule, HeaderModule, SidebarLeftModule, SidebarRightModule, WrapperModule],
                providers: [RoutingService, WrapperService, SidebarRightService, HeaderService, FooterService]
            },] },
];
/**
 * @nocollapse
 */
LayoutModule.ctorParameters = () => [
    { type: LayoutModule, decorators: [{ type: Optional }, { type: SkipSelf },] },
];

var colorsAliases = [
    'default',
    'primary',
    'danger',
    'warning',
    'info',
    'success'
];
var colors = {
    'aqua': '#00c0ef',
    'aqua-active': '#00a7d0',
    'black': '#111111',
    'black-active': '#000000',
    'blue': '#0073b7',
    'blue-active': '#005384',
    'fuchsia': '#f012be',
    'fuchsia-active': '#db0ead',
    'green': '#00a65a',
    'green-active': '#008d4c',
    'gray': '#d2d6de',
    'gray-active': '#b5bbc8',
    'gray-light': '#f7f7f7',
    'light-blue': '#3c8dbc',
    'light-blue-active': '#357ca5',
    'lime': '#01ff70',
    'lime-active': '#00e765',
    'maroon': '#d81b60',
    'maroon-active': '#ca195a',
    'navy': '#001f3f',
    'navy-active': '#001a35',
    'olive': '#3d9970',
    'olive-active': '#368763',
    'orange': '#ff851b',
    'orange-active': '#ff7701',
    'purple': '#605ca8',
    'purple-active': '#555299',
    'red': '#dd4b39',
    'red-active': '#d33724',
    'teal': '#39cccc',
    'teal-active': '#30bbbb',
    'yellow': '#f39c12',
    'yellow-active': '#db8b0b',
};

class BackgroundColorDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer2
     */
    constructor(elementRef, renderer2) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.condition = true;
    }
    /**
     * @param {?} color
     * @return {?}
     */
    set color(color) {
        if (color && this.condition) {
            this.reset();
            if (colors[color]) {
                this.renderer2.addClass(this.elementRef.nativeElement, 'bg-color');
                this.currentStyle = { property: this.property, color: colors[color] };
                this.renderer2.setStyle(this.elementRef.nativeElement, this.property, colors[color]);
            }
            else {
                this.renderer2.removeClass(this.elementRef.nativeElement, 'bg-color');
                if (color.startsWith('#') || color.startsWith('rgb')) {
                    this.currentStyle = { property: this.property, color: color };
                    this.renderer2.setStyle(this.elementRef.nativeElement, this.property, color);
                }
                else if (colorsAliases.indexOf(color) !== -1) {
                    this.currentClass = `${this.prefix}-${color}`;
                    this.renderer2.addClass(this.elementRef.nativeElement, this.currentClass);
                }
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        if (this.currentStyle) {
            this.renderer2.removeStyle(this.elementRef.nativeElement, this.currentStyle.property, this.currentStyle.color);
        }
        else if (this.currentClass) {
            this.renderer2.removeClass(this.elementRef.nativeElement, this.currentClass);
        }
    }
}
BackgroundColorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkColor]'
            },] },
];
/**
 * @nocollapse
 */
BackgroundColorDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
];
BackgroundColorDirective.propDecorators = {
    'condition': [{ type: Input, args: ['mkColorCondition',] },],
    'prefix': [{ type: Input, args: ['mkColorPrefix',] },],
    'property': [{ type: Input, args: ['mkColorProperty',] },],
    'color': [{ type: Input, args: ['mkColor',] },],
};
class ColorDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer2
     */
    constructor(elementRef, renderer2) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
    }
    /**
     * @param {?} color
     * @return {?}
     */
    set color(color) {
        if (color) {
            this.reset();
            if (color.startsWith('#') || color.startsWith('rgb')) {
                this.currentStyle = color;
                this.renderer2.setStyle(this.elementRef.nativeElement, 'color', color);
            }
            else {
                this.currentClass = `text-${color}`;
                this.renderer2.addClass(this.elementRef.nativeElement, this.currentClass);
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        if (this.currentStyle) {
            this.renderer2.removeStyle(this.elementRef.nativeElement, 'color', this.currentStyle);
        }
        else if (this.currentClass) {
            this.renderer2.removeClass(this.elementRef.nativeElement, this.currentClass);
        }
    }
}
ColorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkFontColor]'
            },] },
];
/**
 * @nocollapse
 */
ColorDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
];
ColorDirective.propDecorators = {
    'color': [{ type: Input, args: ['mkFontColor',] },],
};

class ColorModule {
}
ColorModule.decorators = [
    { type: NgModule, args: [{
                exports: [BackgroundColorDirective, ColorDirective],
                declarations: [BackgroundColorDirective, ColorDirective]
            },] },
];
/**
 * @nocollapse
 */
ColorModule.ctorParameters = () => [];

class AccordionToggleDirective {
    /**
     * \@method constructor
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
AccordionToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkAccordionToggle]'
            },] },
];
/**
 * @nocollapse
 */
AccordionToggleDirective.ctorParameters = () => [
    { type: ElementRef, },
];
AccordionToggleDirective.propDecorators = {
    'accordionComponent': [{ type: Input, args: ['mkAccordionToggle',] },],
};

class AccordionHeaderComponent {
}
AccordionHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-accordion-header',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            },] },
];
/**
 * @nocollapse
 */
AccordionHeaderComponent.ctorParameters = () => [];
AccordionHeaderComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
class AccordionContentComponent {
}
AccordionContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-accordion-content',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            },] },
];
/**
 * @nocollapse
 */
AccordionContentComponent.ctorParameters = () => [];
AccordionContentComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
class AccordionComponent {
    constructor() {
        this.contentStyleClass = 'box-body';
        this.headerStyleClass = 'box-header with-border';
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.headerStyleColor = this.headerColor;
        if (!this.header && !this.accordionHeaderComponent) {
            throw new Error('Attribute "header" OR Component "mk-accordion-header" is required for component "mk-accordion"');
        }
        if (this.accordionContentComponent) {
            this.contentTemplateRef = this.accordionContentComponent.templateRef;
        }
        else {
            this.contentTemplateRef = this.templateRef;
        }
    }
}
AccordionComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-accordion',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            },] },
];
/**
 * @nocollapse
 */
AccordionComponent.ctorParameters = () => [];
AccordionComponent.propDecorators = {
    'borderColor': [{ type: Input },],
    'contentColor': [{ type: Input },],
    'contentStyleClass': [{ type: Input },],
    'header': [{ type: Input },],
    'headerColor': [{ type: Input },],
    'headerColorHover': [{ type: Input },],
    'headerStyleClass': [{ type: Input },],
    'accordionHeaderComponent': [{ type: ContentChild, args: [AccordionHeaderComponent,] },],
    'accordionContentComponent': [{ type: ContentChild, args: [AccordionContentComponent,] },],
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
class AccordionGroupComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef
     * @param {?} ngZone
     * @param {?} renderer2
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.activeIndex = [0];
        this.listeners = [];
        this.subscriptions = [];
        this.styleClass = 'box-group';
        this.onCollapseStart = new EventEmitter();
        this.onCollapseDone = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _activeIndex(value) {
        this.activeIndex = value instanceof Array ? value : [value];
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterContentInit() {
        this.setAccordionsIndex();
        this.updateAccordionIsCollapsed();
        this.subscriptions.push(this.accordionComponents.changes.subscribe(changes => {
            this.setAccordionsIndex();
        }));
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.setAccordionsToggle();
        this.subscriptions.push(this.accordionToggleDirectives.changes.subscribe(changes => {
            this.setAccordionsToggle();
        }));
    }
    /**
     * [ngOnChanges description]
     * \@method ngOnChanges
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes._activeIndex.firstChange === false) {
            this.updateAccordionIsCollapsed();
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
        removeSubscriptions(this.subscriptions);
    }
    /**
     * [headerMouseEnter description]
     * \@method headerMouseEnter
     * @param {?} accordion
     * @return {?}
     */
    headerMouseEnter(accordion) {
        if (accordion.headerColorHover) {
            accordion.headerStyleColor = accordion.headerColorHover;
        }
    }
    /**
     * [headerMouseLeave description]
     * \@method headerMouseLeave
     * @param {?} accordion
     * @return {?}
     */
    headerMouseLeave(accordion) {
        accordion.headerStyleColor = accordion.headerColor;
    }
    /**
     * [toggleAccordion description]
     * \@method toggleAccordion
     * @param {?} event
     * @param {?} toggleIndex
     * @return {?}
     */
    toggleAccordion(event, toggleIndex) {
        event.preventDefault();
        let /** @type {?} */ indexOf = this.activeIndex['indexOf'](toggleIndex);
        if (indexOf === -1) {
            if (this.isMultiple) {
                this.activeIndex.push(toggleIndex);
            }
            else {
                this.activeIndex = [toggleIndex];
            }
        }
        else {
            if (this.isMultiple) {
                this.activeIndex.splice(indexOf, 1);
            }
            else {
                this.activeIndex = [];
            }
        }
        this.updateAccordionIsCollapsed();
    }
    /**
     * [collapseStart description]
     * \@method collapseStart
     * @param {?} event
     * @param {?} accordion
     * @return {?}
     */
    collapseStart(event, accordion) {
        accordion.isCollapsing = true;
        this.onCollapseStart.emit({ animationEvent: event, index: accordion.index });
    }
    /**
     * [collapseDone description]
     * \@method collapseDone
     * @param {?} event
     * @param {?} accordion
     * @return {?}
     */
    collapseDone(event, accordion) {
        accordion.isCollapsing = false;
        this.onCollapseDone.emit({ animationEvent: event, index: accordion.index });
    }
    /**
     * [setAccordionsIndex description]
     * \@method setAccordionsIndex
     * @return {?}
     */
    setAccordionsIndex() {
        this.accordionComponents.forEach((accordion, index) => {
            accordion.index = index;
        });
    }
    /**
     * [setAccordionsToggle description]
     * \@method setAccordionsToggle
     * @return {?}
     */
    setAccordionsToggle() {
        this.listeners = removeListeners(this.listeners);
        this.ngZone.runOutsideAngular(() => {
            this.accordionToggleDirectives.forEach((accordionToggle) => {
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'click', (event) => {
                    this.toggleAccordion(event, accordionToggle.accordionComponent.index);
                    this.changeDetectorRef.detectChanges();
                }));
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'mouseenter', (event) => {
                    this.headerMouseEnter(accordionToggle.accordionComponent);
                    this.changeDetectorRef.detectChanges();
                }));
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'mouseleave', (event) => {
                    this.headerMouseLeave(accordionToggle.accordionComponent);
                    this.changeDetectorRef.detectChanges();
                }));
            });
        });
    }
    /**
     * [updateAccordionIsCollapsed description]
     * \@method updateAccordionIsCollapsed
     * @return {?}
     */
    updateAccordionIsCollapsed() {
        this.accordionComponents.forEach((accordion, index) => {
            if (this.activeIndex.indexOf(index) === -1) {
                accordion.isCollapsed = true;
            }
            else {
                accordion.isCollapsed = false;
            }
        });
    }
}
AccordionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-accordion-group',
                template: `
    <div [ngClass]="styleClass">
      <div *ngFor="let accordion of accordionComponents" class="panel box" [mkColor]="accordion.borderColor" mkColorProperty="border-top-color" mkColorPrefix="box">
        <div [ngClass]="accordion.headerStyleClass" [class.no-border]="accordion.isCollapsed && !accordion.isCollapsing">
          <h4 class="box-title">
            <a [mkAccordionToggle]="accordion" href="#" [mkFontColor]="accordion.headerStyleColor" [class.collapsed]="accordion.isCollapsed">
              {{accordion.header}}
              <ng-template *ngIf="!accordion.header" [ngTemplateOutlet]="accordion.accordionTitleComponent?.templateRef"></ng-template>
            </a>
          </h4>
        </div>
        <div class="panel-collapse" [collapseAnimation]="accordion.isCollapsed" (collapseAnimation.start)="collapseStart($event, accordion)" (collapseAnimation.done)="collapseDone($event, accordion)">
          <div [ngClass]="accordion.contentStyleClass" [mkFontColor]="accordion.contentColor">
            <ng-template [ngTemplateOutlet]="accordion.contentTemplateRef"></ng-template>
          </div>
        </div>
      </div>
    </div>
  `
            },] },
];
/**
 * @nocollapse
 */
AccordionGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: NgZone, },
    { type: Renderer2, },
];
AccordionGroupComponent.propDecorators = {
    '_activeIndex': [{ type: Input, args: ['activeIndex',] },],
    'isMultiple': [{ type: Input },],
    'styleClass': [{ type: Input },],
    'onCollapseStart': [{ type: Output },],
    'onCollapseDone': [{ type: Output },],
    'accordionComponents': [{ type: ContentChildren, args: [AccordionComponent,] },],
    'accordionToggleDirectives': [{ type: ViewChildren, args: [AccordionToggleDirective,] },],
};

class AccordionModule {
}
AccordionModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, AnimationsModule, ColorModule],
                exports: [AccordionHeaderComponent, AccordionContentComponent, AccordionComponent, AccordionGroupComponent],
                declarations: [AccordionToggleDirective, AccordionHeaderComponent, AccordionContentComponent, AccordionComponent, AccordionGroupComponent]
            },] },
];
/**
 * @nocollapse
 */
AccordionModule.ctorParameters = () => [];

class AlertComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef
     * @param {?} ngZone
     * @param {?} renderer2
     * @param {?} viewContainerRef
     */
    constructor(changeDetectorRef, ngZone, renderer2, viewContainerRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.viewContainerRef = viewContainerRef;
        this.dismissibleClass = 'alert-dismissible';
        this.isDismissible = true;
        this.remove = false;
        this.type = 'alert';
        this.listeners = [];
        this.backgroundColor = 'danger';
        this.styleClass = '';
        this.onCollapseStart = new EventEmitter();
        this.onCollapseDone = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set callout(value) {
        this.type = value ? 'callout' : 'alert';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _isDismissible(value) {
        this.isDismissible = value;
        if (value) {
            this.dismissibleClass = `${this.type}-dismissible`;
        }
        else {
            this.dismissibleClass = '';
        }
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            if (this.dismissOnTimeout) {
                setTimeout(() => {
                    if (!((this.changeDetectorRef)).destroyed) {
                        this.remove = true;
                        this.changeDetectorRef.detectChanges();
                    }
                }, this.dismissOnTimeout);
            }
            if (this.removeButtonElement) {
                this.listeners.push(this.renderer2.listen(this.removeButtonElement.nativeElement, 'click', (event) => {
                    this.remove = true;
                    this.changeDetectorRef.detectChanges();
                }));
            }
        });
    }
    /**
     * \@method ngOnDesroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
    }
    /**
     * [collapseStart description]
     * \@method collapseStart
     * @param {?} event
     * @return {?}
     */
    collapseStart(event) {
        this.onCollapseStart.emit(event);
    }
    /**
     * [collapseDone description]
     * \@method collapseDone
     * @param {?} event
     * @return {?}
     */
    collapseDone(event) {
        if (event.toState === '1') {
            this.listeners = removeListeners(this.listeners);
            this.removed = true;
            this.viewContainerRef.clear();
            this.changeDetectorRef.detectChanges();
        }
        this.onCollapseDone.emit(event);
    }
}
AlertComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-alert',
                template: `
    <div *ngIf="!removed" [collapseAnimation]="remove" (collapseAnimation.start)="collapseStart($event)" (collapseAnimation.done)="collapseDone($event)">
      <div [mkColor]="backgroundColor" mkColorProperty="background-color" [mkColorPrefix]="type" [mkFontColor]="color" [ngClass]="[styleClass, dismissibleClass, type]">
        <button *ngIf="isDismissible" type="button" class="close" #removeButtonElement>&times;</button>
        <ng-content></ng-content>
      </div>
    </div>
  `,
                styles: [`
    .callout-dismissable,
    .callout-dismissible {
      padding-right: 35px;
    }

    .callout-dismissable .close,
    .callout-dismissible .close {
        position: relative;
        top: -2px;
        right: -21px;
        color: inherit;
    }

    .callout .close {
      color: #000;
      opacity: 0.2;
      filter: alpha(opacity=20);
    }

    .callout .icon {
      margin-right: 10px;
    }
  `],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
AlertComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: NgZone, },
    { type: Renderer2, },
    { type: ViewContainerRef, },
];
AlertComponent.propDecorators = {
    'backgroundColor': [{ type: Input },],
    'callout': [{ type: Input },],
    'color': [{ type: Input },],
    'dismissOnTimeout': [{ type: Input },],
    '_isDismissible': [{ type: Input, args: ['isDismissible',] },],
    'styleClass': [{ type: Input },],
    'onCollapseStart': [{ type: Output },],
    'onCollapseDone': [{ type: Output },],
    'removeButtonElement': [{ type: ViewChild, args: ['removeButtonElement',] },],
    'containerElementRef': [{ type: ViewChild, args: ['containerElementRef', { read: ViewContainerRef },] },],
};

class AlertModule {
}
AlertModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, AnimationsModule, ColorModule],
                exports: [AlertComponent],
                declarations: [AlertComponent]
            },] },
];
/**
 * @nocollapse
 */
AlertModule.ctorParameters = () => [];

class BoxContentDirective {
}
BoxContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-content'
            },] },
];
/**
 * @nocollapse
 */
BoxContentDirective.ctorParameters = () => [];
class BoxFooterDirective {
}
BoxFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-footer'
            },] },
];
/**
 * @nocollapse
 */
BoxFooterDirective.ctorParameters = () => [];
class BoxToolsDirective {
}
BoxToolsDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-tools'
            },] },
];
/**
 * @nocollapse
 */
BoxToolsDirective.ctorParameters = () => [];
class BoxHeaderDirective {
}
BoxHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-header'
            },] },
];
/**
 * @nocollapse
 */
BoxHeaderDirective.ctorParameters = () => [];

class BoxComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef
     * @param {?} ngZone
     * @param {?} renderer2
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.remove = false;
        this.listeners = [];
        this.boxColor = 'default';
        this.buttonsStyleClass = 'btn btn-box-tool';
        this.contentStyleClass = 'box-content-wrapper';
        this.footerStyleClass = 'box-footer';
        this.headerBorder = true;
        this.headerStyleClass = 'box-header';
        this.isCollapsable = true;
        this.isCollapsed = false;
        this.isRemovable = true;
        this.isSolid = false;
        this.loadingStyleClass = 'fa fa-refresh fa-spin';
        this.styleClass = 'box';
        this.onCollapseDone = new EventEmitter();
        this.onCollapseStart = new EventEmitter();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            if (this.toggleButtonElement) {
                this.listeners.push(this.renderer2.listen(this.toggleButtonElement.nativeElement, 'click', (event) => {
                    this.isCollapsed = !this.isCollapsed;
                    this.changeDetectorRef.detectChanges();
                }));
            }
            if (this.removeButtonElement) {
                this.listeners.push(this.renderer2.listen(this.removeButtonElement.nativeElement, 'click', (event) => {
                    this.remove = true;
                    this.changeDetectorRef.detectChanges();
                }));
            }
        });
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
    }
    /**
     * [removedDone description]
     * \@method removedDone
     * @param {?} event
     * @return {?}
     */
    removedDone(event) {
        if (event.toState === '1') {
            this.removed = true;
        }
    }
    /**
     * [collapseStart description]
     * \@method collapseStart
     * @param {?} event
     * @return {?}
     */
    collapseStart(event) {
        if (event.fromState !== 'void') {
            this.isCollaping = true;
            this.onCollapseStart.emit(event);
        }
    }
    /**
     * [collapseDone description]
     * \@method collapseDone
     * @param {?} event
     * @return {?}
     */
    collapseDone(event) {
        if (event.fromState !== 'void') {
            this.isCollaping = false;
            this.onCollapseDone.emit(event);
        }
    }
}
BoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-box',
                template: `
    <div *ngIf="!removed" [mkColor]="boxColor" mkColorProperty="border-color" mkColorPrefix="box" [ngClass]="styleClass" [class.collapsed-box]="isCollapsed && !isCollaping" [class.box-solid]="isSolid" [collapseAnimation]="remove" (collapseAnimation.done)="removedDone($event)">
      <div *ngIf="header || boxHeaderDirective" [ngClass]="headerStyleClass" [mkColor]="boxColor" [mkColorCondition]="isSolid" mkColorProperty="background-color" [class.with-border]="headerBorder">
        <h3 class="box-title" [mkFontColor]="headerColor">
          {{header}}
          <ng-content select="mk-box-header"></ng-content>
        </h3>
        <div class="box-tools pull-right">
          <ng-content select="mk-box-tools"></ng-content>
          <button *ngIf="isCollapsable" type="button" [ngClass]="buttonsStyleClass" #toggleButtonElement>
            <i class="fa" [ngClass]="{'fa-plus': isCollapsed, 'fa-minus': !isCollapsed}"></i>
          </button>
          <button *ngIf="isRemovable" type="button" [ngClass]="buttonsStyleClass" #removeButtonElement>
            <i class="fa fa-times"></i>
          </button>
        </div>
      </div>
      <div [ngClass]="contentStyleClass" [mkFontColor]="contentColor" [collapseAnimation]="isCollapsed" (collapseAnimation.start)="collapseStart($event)" (collapseAnimation.done)="collapseDone($event)">
        <div class="box-body">
          <ng-container *ngIf="boxHeaderDirective || boxContentDirective || boxFooterDirective || BoxToolsDirective else noDirective">
            <ng-content select="mk-box-content"></ng-content>
          </ng-container>
          <ng-template #noDirective>
            <ng-content></ng-content>
          </ng-template>
        </div>
        <div *ngIf="footer || boxFooterDirective" [ngClass]="footerSyleClass" [mkFontColor]="footerColor">
          {{footer}}
          <ng-content select="mk-box-footer"></ng-content>
        </div>
      </div>
      <div *ngIf="isLoading" class="overlay">
        <i [ngClass]="loadingStyleClass" [mkFontColor]="loadingColor"></i>
      </div>
    </div>
  `,
                styles: [`
    .box.collapsed-box .box-body,
    .box.collapsed-box .box-footer {
      display: inherit;
    }

    .box-solid {
      border: 1px solid;
    }

    .box-body {
      background-color: #fff;
    }

    .box.box-solid.bg-color > .box-header {
      color: #fff;
    }
  `],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
BoxComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: NgZone, },
    { type: Renderer2, },
];
BoxComponent.propDecorators = {
    'boxColor': [{ type: Input },],
    'buttonsStyleClass': [{ type: Input },],
    'contentStyleClass': [{ type: Input },],
    'contentColor': [{ type: Input },],
    'footer': [{ type: Input },],
    'footerColor': [{ type: Input },],
    'footerStyleClass': [{ type: Input },],
    'header': [{ type: Input },],
    'headerBorder': [{ type: Input },],
    'headerColor': [{ type: Input },],
    'headerStyleClass': [{ type: Input },],
    'isCollapsable': [{ type: Input },],
    'isCollapsed': [{ type: Input },],
    'isLoading': [{ type: Input },],
    'isRemovable': [{ type: Input },],
    'isSolid': [{ type: Input },],
    'loadingColor': [{ type: Input },],
    'loadingStyleClass': [{ type: Input },],
    'styleClass': [{ type: Input },],
    'onCollapseDone': [{ type: Output },],
    'onCollapseStart': [{ type: Output },],
    'boxHeaderDirective': [{ type: ContentChild, args: [BoxHeaderDirective,] },],
    'boxFooterDirective': [{ type: ContentChild, args: [BoxFooterDirective,] },],
    'boxContentDirective': [{ type: ContentChild, args: [BoxContentDirective,] },],
    'boxToolsDirective': [{ type: ContentChild, args: [BoxToolsDirective,] },],
    'toggleButtonElement': [{ type: ViewChild, args: ['toggleButtonElement',] },],
    'removeButtonElement': [{ type: ViewChild, args: ['removeButtonElement',] },],
};

class BoxModule {
}
BoxModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, AnimationsModule, ColorModule],
                exports: [BoxComponent, BoxHeaderDirective, BoxContentDirective, BoxFooterDirective, BoxToolsDirective],
                declarations: [BoxComponent, BoxHeaderDirective, BoxContentDirective, BoxFooterDirective, BoxToolsDirective]
            },] },
];
/**
 * @nocollapse
 */
BoxModule.ctorParameters = () => [];

class BoxInfoContentDirective {
}
BoxInfoContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-info-content'
            },] },
];
/**
 * @nocollapse
 */
BoxInfoContentDirective.ctorParameters = () => [];
class BoxInfoFooterDirective {
}
BoxInfoFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-info-footer'
            },] },
];
/**
 * @nocollapse
 */
BoxInfoFooterDirective.ctorParameters = () => [];
class BoxInfoHeaderDirective {
}
BoxInfoHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-info-header'
            },] },
];
/**
 * @nocollapse
 */
BoxInfoHeaderDirective.ctorParameters = () => [];

class BoxInfoComponent {
    constructor() {
        this.contentStyleClass = 'info-box-number';
        this.footerStyleClass = 'progress-description';
        this.headerStyleClass = 'info-box-text';
        this.iconColor = '#fff';
        this.iconStyleClass = 'ion ion-bag';
        this.styleClass = 'info-box';
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        if (!this.backgroundColor) {
            this.progressBarBg = this.iconBackgroundColor;
        }
    }
}
BoxInfoComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-box-info',
                styles: [`
    .info-box.bg-color > .info-box-content {
      color: #fff;
    }
  `],
                template: `
    <div [ngClass]="styleClass" [mkColor]="backgroundColor" mkColorProperty="background-color">
      <span class="info-box-icon" [mkColor]="iconBackgroundColor" mkColorProperty="background-color">
        <i [ngClass]="iconStyleClass" [mkFontColor]="iconColor"></i>
      </span>
      <div class="info-box-content">
        <span *ngIf="header || boxInfoHeaderDirective" [ngClass]="headerStyleClass" [mkFontColor]="headerColor">
          {{header}}
          <ng-content select="mk-box-header"></ng-content>
        </span>
        <span [ngClass]="contentStyleClass" [mkFontColor]="contentColor">
          <ng-container *ngIf="boxInfoHeaderDirective || boxInfoContentDirective || boxInfoFooterDirective else noDirective">
            <ng-content select="mk-box-content"></ng-content>
          </ng-container>
          <ng-template #noDirective>
            <ng-content></ng-content>
          </ng-template>
        </span>
        <div *ngIf="progressWidth" class="progress">
          <div class="progress-bar" [mkColor]="progressBarBg" mkColorProperty="background-color" [style.width.%]="progressWidth"></div>
        </div>
        <span *ngIf="footer || boxInfoFooterDirective" [ngClass]="footerStyleClass" [mkFontColor]="footerColor">
          {{footer}}
          <ng-content select="mk-box-footer"></ng-content>
        </span>
      </div>
    </div>
  `
            },] },
];
/**
 * @nocollapse
 */
BoxInfoComponent.ctorParameters = () => [];
BoxInfoComponent.propDecorators = {
    'backgroundColor': [{ type: Input },],
    'contentStyleClass': [{ type: Input },],
    'contentColor': [{ type: Input },],
    'footer': [{ type: Input },],
    'footerColor': [{ type: Input },],
    'footerStyleClass': [{ type: Input },],
    'header': [{ type: Input },],
    'headerColor': [{ type: Input },],
    'headerStyleClass': [{ type: Input },],
    'iconBackgroundColor': [{ type: Input },],
    'iconColor': [{ type: Input },],
    'iconStyleClass': [{ type: Input },],
    'progressWidth': [{ type: Input },],
    'styleClass': [{ type: Input },],
    'boxInfoHeaderDirective': [{ type: ContentChild, args: [BoxInfoHeaderDirective,] },],
    'boxInfoFooterDirective': [{ type: ContentChild, args: [BoxInfoFooterDirective,] },],
    'boxInfoContentDirective': [{ type: ContentChild, args: [BoxInfoContentDirective,] },],
};

class BoxInfoModule {
}
BoxInfoModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ColorModule],
                exports: [BoxInfoComponent, BoxInfoHeaderDirective, BoxInfoContentDirective, BoxInfoFooterDirective],
                declarations: [BoxInfoComponent, BoxInfoHeaderDirective, BoxInfoContentDirective, BoxInfoFooterDirective]
            },] },
];
/**
 * @nocollapse
 */
BoxInfoModule.ctorParameters = () => [];

class BoxSmallFooterDirective {
}
BoxSmallFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-small-footer'
            },] },
];
/**
 * @nocollapse
 */
BoxSmallFooterDirective.ctorParameters = () => [];
class BoxSmallHeaderDirective {
}
BoxSmallHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-small-header'
            },] },
];
/**
 * @nocollapse
 */
BoxSmallHeaderDirective.ctorParameters = () => [];
class BoxSmallContentDirective {
}
BoxSmallContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-box-small-content'
            },] },
];
/**
 * @nocollapse
 */
BoxSmallContentDirective.ctorParameters = () => [];

class BoxSmallComponent {
    constructor() {
        this.contentStyleClass = 'small-box-content';
        this.footerStyleClass = 'small-box-footer';
        this.headerStyleClass = 'small-box-header';
        this.iconStyleClass = 'ion ion-bag';
        this.styleClass = 'small-box';
    }
}
BoxSmallComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-box-small',
                template: `
    <div [ngClass]="styleClass" [mkColor]="backgroundColor" mkColorProperty="background-color">
      <div class="inner">
        <h3 *ngIf="header || boxSmallHeaderDirective" [ngClass]="headerStyleClass" [mkFontColor]="headerColor">
          {{header}}
          <ng-content select="mk-box-small-header"></ng-content>
        </h3>
        <p [ngClass]="contentStyleClass" [mkFontColor]="contentColor">
          <ng-container *ngIf="boxSmallHeaderDirective || boxSmallContentDirective || boxSmallFooterDirective else noDirective">
            <ng-content select="mk-box-small-content"></ng-content>
          </ng-container>
          <ng-template #noDirective>
            <ng-content></ng-content>
          </ng-template>
        </p>
      </div>
      <div *ngIf="iconStyleClass" class="icon">
        <i [ngClass]="iconStyleClass" [mkFontColor]="iconColor"></i>
      </div>
      <span *ngIf="footer || boxSmallFooterDirective" [ngClass]="footerStyleClass" [mkFontColor]="footerColor">
        {{footer}}
        <ng-content select="mk-box-small-footer"></ng-content>
      </span>
    </div>
  `,
                styles: [`
    .small-box.bg-color {
      color: #fff;
    }

    /deep/ .small-box-footer:hover {
      cursor: pointer;
    }

    /deep/ .small-box-footer a {
      color: rgba(255,255,255,0.8);
    }

    /deep/ .small-box-footer:hover a{
      color: rgb(255,255,255);
    }
  `]
            },] },
];
/**
 * @nocollapse
 */
BoxSmallComponent.ctorParameters = () => [];
BoxSmallComponent.propDecorators = {
    'backgroundColor': [{ type: Input },],
    'contentColor': [{ type: Input },],
    'contentStyleClass': [{ type: Input },],
    'footer': [{ type: Input },],
    'footerColor': [{ type: Input },],
    'footerStyleClass': [{ type: Input },],
    'header': [{ type: Input },],
    'headerColor': [{ type: Input },],
    'headerStyleClass': [{ type: Input },],
    'iconColor': [{ type: Input },],
    'iconStyleClass': [{ type: Input },],
    'styleClass': [{ type: Input },],
    'boxSmallHeaderDirective': [{ type: ContentChild, args: [BoxSmallHeaderDirective,] },],
    'boxSmallFooterDirective': [{ type: ContentChild, args: [BoxSmallFooterDirective,] },],
    'boxSmallContentDirective': [{ type: ContentChild, args: [BoxSmallContentDirective,] },],
};

class BoxSmallModule {
}
BoxSmallModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ColorModule],
                exports: [BoxSmallComponent, BoxSmallHeaderDirective, BoxSmallContentDirective, BoxSmallFooterDirective],
                declarations: [BoxSmallComponent, BoxSmallHeaderDirective, BoxSmallContentDirective, BoxSmallFooterDirective]
            },] },
];
/**
 * @nocollapse
 */
BoxSmallModule.ctorParameters = () => [];

class DropdownToggleComponent {
}
DropdownToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-dropdown-toggle',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
DropdownToggleComponent.ctorParameters = () => [];
DropdownToggleComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
    'toggleElement': [{ type: ContentChild, args: ['toggleElement',] },],
};
class DropdownMenuComponent {
}
DropdownMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-dropdown-menu',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
DropdownMenuComponent.ctorParameters = () => [];
DropdownMenuComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
class DropdownComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef
     * @param {?} elementRef
     * @param {?} ngZone
     * @param {?} renderer2
     */
    constructor(changeDetectorRef, elementRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.listeners = [];
        this.buttonStyleClass = 'btn dropdown-toggle';
        this.buttonBackgroudColor = 'default';
        this.contentStyleClass = 'dropdown-menu';
        this.isCollapsed = true;
        this.isWrapper = true;
        this.styleClass = 'dropdown';
        this.onCollapseStart = new EventEmitter();
        this.onCollapseDone = new EventEmitter();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        let /** @type {?} */ toggleNativeElement = this.dropdownToggleComponent && this.dropdownToggleComponent.toggleElement ?
            this.dropdownToggleComponent.toggleElement.nativeElement : this.toggleElement ?
            this.toggleElement : this.defaultToggleElement ?
            this.defaultToggleElement.nativeElement : null;
        if (toggleNativeElement) {
            this.ngZone.runOutsideAngular(() => {
                this.listeners.push(this.renderer2.listen(toggleNativeElement, 'click', (event) => {
                    this.toggleDropdown(event);
                    this.changeDetectorRef.detectChanges();
                }));
            });
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.unBindDocumentClickListener();
        removeListeners(this.listeners);
    }
    /**
     * [toggle description]
     * \@method toggle
     * @param {?} event
     * @return {?}
     */
    toggleDropdown(event) {
        event.preventDefault();
        this.isCollapsed = !this.isCollapsed;
        if (!this.isCollapsed) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.bindDocumentClickListener();
                });
            });
        }
        else {
            this.unBindDocumentClickListener();
        }
    }
    /**
     * [collapseStart description]
     * \@method collapseStart
     * @param {?} event
     * @return {?}
     */
    collapseStart(event) {
        this.onCollapseStart.emit(event);
    }
    /**
     * [collapseDone description]
     * \@method collapseDone
     * @param {?} event
     * @return {?}
     */
    collapseDone(event) {
        this.onCollapseStart.emit(event);
    }
    /**
     * [bindDocumentClickListener description]
     * \@method bindDocumentClickListener
     * @return {?}
     */
    bindDocumentClickListener() {
        this.ngZone.runOutsideAngular(() => {
            this.documentClickListener = this.renderer2.listen('document', 'click', (event) => {
                if (!this.isCollapsed) {
                    this.isCollapsed = true;
                    this.unBindDocumentClickListener();
                    this.changeDetectorRef.detectChanges();
                }
            });
        });
    }
    /**
     * [unBindDocumentClickListener description]
     * \@method unBindDocumentClickListener
     * @return {?}
     */
    unBindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
        }
    }
}
DropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-dropdown, [mk-dropdown]',
                template: `
    <ng-template #innerTemplate>
      <ng-container *ngIf="this.dropdownToggleComponent && this.dropdownToggleComponent.toggleElement else noToggleElement" [ngTemplateOutlet]="dropdownToggleComponent.templateRef"></ng-container>
      <ng-template #noToggleElement>
        <button *ngIf="toggleText || dropdownToggleComponent" [mkColor]="buttonBackgroudColor" mkColorProperty="background-color" mkColorPrefix="btn" [ngClass]="buttonStyleClass" #toggleElement>
          {{toggleText}}
          <ng-container [ngTemplateOutlet]="dropdownToggleComponent?.templateRef"></ng-container>
        </button>
      </ng-template>
      <ul [ngClass]="contentStyleClass" [collapseAnimation]="isCollapsed" (collapseAnimation.start)="collapseStart($event)" (collapseAnimation.done)="collapseDone($event)">
        <ng-container *ngIf="dropdownMenuComponent else noDropdownMenuComponent" [ngTemplateOutlet]="dropdownMenuComponent.templateRef"></ng-container>
        <ng-template #noDropdownMenuComponent>
          <ng-content></ng-content>
        </ng-template>
      </ul>
    </ng-template>

    <div *ngIf="isWrapper else noWrapper" [ngClass]="styleClass">
      <ng-container *ngTemplateOutlet="innerTemplate"></ng-container>
    </div>

    <ng-template #noWrapper>
      <ng-container *ngTemplateOutlet="innerTemplate"></ng-container>
    </ng-template>
  `,
                styles: [`
    .dropdown-menu {
      display: block;
    }

    .dropdown-menu.collapsing:not(.un-collapse) {
      -webkit-transition-property: height, padding-top, padding-bottom;
      transition-property: height, padding-top, padding-bottom;
      padding-top: 0;
      padding-bottom: 0;
    }
  `],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
DropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: ElementRef, },
    { type: NgZone, },
    { type: Renderer2, },
];
DropdownComponent.propDecorators = {
    'buttonStyleClass': [{ type: Input },],
    'buttonBackgroudColor': [{ type: Input },],
    'contentStyleClass': [{ type: Input },],
    'isCollapsed': [{ type: Input },],
    'isWrapper': [{ type: Input },],
    'styleClass': [{ type: Input },],
    'toggleElement': [{ type: Input },],
    'toggleText': [{ type: Input },],
    'onCollapseStart': [{ type: Output },],
    'onCollapseDone': [{ type: Output },],
    'dropdownToggleComponent': [{ type: ContentChild, args: [DropdownToggleComponent,] },],
    'dropdownMenuComponent': [{ type: ContentChild, args: [DropdownMenuComponent,] },],
    'defaultToggleElement': [{ type: ViewChild, args: ['toggleElement',] },],
};

class DropdownModule {
}
DropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, AnimationsModule, ColorModule],
                exports: [DropdownComponent, DropdownToggleComponent, DropdownMenuComponent],
                declarations: [DropdownComponent, DropdownToggleComponent, DropdownMenuComponent]
            },] },
];
/**
 * @nocollapse
 */
DropdownModule.ctorParameters = () => [];

class InputTextLabelDirective {
}
InputTextLabelDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-input-text-label'
            },] },
];
/**
 * @nocollapse
 */
InputTextLabelDirective.ctorParameters = () => [];
class InputTextAddonLeftDirective {
}
InputTextAddonLeftDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-input-text-addon-left'
            },] },
];
/**
 * @nocollapse
 */
InputTextAddonLeftDirective.ctorParameters = () => [];
class InputTextAddonRightDirective {
}
InputTextAddonRightDirective.decorators = [
    { type: Directive, args: [{
                selector: 'mk-input-text-addon-right'
            },] },
];
/**
 * @nocollapse
 */
InputTextAddonRightDirective.ctorParameters = () => [];

class InputTextComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef
     * @param {?} renderer2
     */
    constructor(changeDetectorRef, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.renderer2 = renderer2;
        this.listeners = [];
        this.id = new Date().valueOf();
        this.wrapperClasses = 'form-group';
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        //this.ngZone.runOutsideAngular(() => { #BUG
        this.listeners.push(this.renderer2.listen(this.inputElement.nativeElement, 'input', (event) => {
            this.onChange(((event.target)).value);
            this.changeDetectorRef.detectChanges();
        }));
        this.listeners.push(this.renderer2.listen(this.inputElement.nativeElement, 'blur', (event) => {
            this.onTouched();
            this.changeDetectorRef.detectChanges();
        }));
        //});
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
    }
    /**
     * [registerOnChange description]
     * \@method registerOnChange
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * [registerOnTouched description]
     * \@method registerOnTouched
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * [setDisabledState description]
     * \@method setDisabledState
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.renderer2.setProperty(this.inputElement.nativeElement, 'disabled', isDisabled);
    }
    /**
     * [writeValue description]
     * \@method writeValue
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            this.value = value;
        }
    }
}
InputTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-input-text',
                template: `
    <div [ngClass]="wrapperClasses" [mkColor]="inputColor" mkColorPrefix="has">
      <label *ngIf="addonLeft || inputTextLabelDirective" for="{{id}}">
        {{label}}
        <ng-content select="mk-input-text-label"></ng-content>
      </label>
      <div class="input-group">
        <span *ngIf="addonLeft || inputTextAddonLeftDirective" class="input-group-addon" [mkColor]="inputColor" mkColorProperty="border-color">
          {{addonLeft}}
          <ng-content select="mk-input-text-addon-left"></ng-content>
        </span>
        <input #inputElement type="text" class="form-control" [ngClass]="size === 'small' ? 'input-sm' : size === 'large' ? 'input-lg': ''" id="{{id}}" placeholder="{{placeholder}}" [(ngModel)]="value" [disabled]="isDisabled" [mkColor]="inputColor" mkColorProperty="border-color" [mkFontColor]="inputFontColor">
        <span *ngIf="addonRight || inputTextAddonRightDirective" class="input-group-addon" [mkColor]="inputColor" mkColorProperty="border-color">
          {{addonRight}}
          <ng-content select="mk-input-text-addon-right"></ng-content>
        </span>
      </div>
    </div>
  `,
                styles: [`

  `],
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => InputTextComponent),
                        multi: true
                    }]
            },] },
];
/**
 * @nocollapse
 */
InputTextComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: Renderer2, },
];
InputTextComponent.propDecorators = {
    'addonLeft': [{ type: Input },],
    'addonRight': [{ type: Input },],
    'id': [{ type: Input },],
    'inputColor': [{ type: Input },],
    'inputFontColor': [{ type: Input },],
    'isDisabled': [{ type: Input },],
    'label': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'size': [{ type: Input },],
    'wrapperClasses': [{ type: Input },],
    'inputElement': [{ type: ViewChild, args: ['inputElement',] },],
    'inputTextLabelDirective': [{ type: ContentChild, args: [InputTextLabelDirective,] },],
    'inputTextAddonLeftDirective': [{ type: ContentChild, args: [InputTextAddonLeftDirective,] },],
    'inputTextAddonRightDirective': [{ type: ContentChild, args: [InputTextAddonRightDirective,] },],
};

class InputTextModule {
}
InputTextModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ColorModule,
                    FormsModule
                ],
                exports: [InputTextComponent, InputTextLabelDirective, InputTextAddonLeftDirective, InputTextAddonRightDirective],
                declarations: [InputTextComponent, InputTextLabelDirective, InputTextAddonLeftDirective, InputTextAddonRightDirective]
            },] },
];
/**
 * @nocollapse
 */
InputTextModule.ctorParameters = () => [];

class TabToggleDirective {
    /**
     * \@method constructor
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
TabToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkTabToggle]'
            },] },
];
/**
 * @nocollapse
 */
TabToggleDirective.ctorParameters = () => [
    { type: ElementRef, },
];
TabToggleDirective.propDecorators = {
    'tabComponent': [{ type: Input, args: ['mkTabToggle',] },],
};

class TabHeaderComponent {
}
TabHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tab-header',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
TabHeaderComponent.ctorParameters = () => [];
TabHeaderComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
class TabContentComponent {
}
TabContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tab-content',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
TabContentComponent.ctorParameters = () => [];
TabContentComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
class TabComponent {
    constructor() {
        this.isActive = false;
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        if (this.tabContentComponent) {
            this.contentTemplateRef = this.tabContentComponent.templateRef;
        }
        else {
            this.contentTemplateRef = this.templateRef;
        }
    }
}
TabComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tab',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
TabComponent.ctorParameters = () => [];
TabComponent.propDecorators = {
    'header': [{ type: Input },],
    'isDisabled': [{ type: Input },],
    'tabColor': [{ type: Input },],
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
    'tabHeaderComponent': [{ type: ContentChild, args: [TabHeaderComponent,] },],
    'tabContentComponent': [{ type: ContentChild, args: [TabContentComponent,] },],
};
class TabsHeaderComponent {
}
TabsHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tabs-header',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
TabsHeaderComponent.ctorParameters = () => [];
TabsHeaderComponent.propDecorators = {
    'templateRef': [{ type: ViewChild, args: ['templateRef',] },],
};
class TabsComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef
     * @param {?} ngZone
     * @param {?} renderer2
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.listeners = [];
        this.subscriptions = [];
        this.headerStyleClass = 'header pull-left';
        this.navStyleClass = 'nav nav-tabs';
        this.contentStyleClass = 'tab-content';
        this.styleClass = 'nav-tabs-custom';
        this.onClose = new EventEmitter();
        this.onOpen = new EventEmitter();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    set activeTabIndex(index) {
        this.activatedTabIndex = index;
        this.changeDetectorRef.detectChanges();
    }
    /**
     * @return {?}
     */
    get activeTabIndex() {
        return this.activatedTabIndex;
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterContentInit() {
        // Set tab index on load.
        this.setTabIndex();
        // Update tab index if tabs is updated.
        this.subscriptions.push(this.tabs.changes.subscribe(changes => {
            this.setTabIndex();
        }));
        // Open tab on load.
        this.openTabIndex();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        // Set tab toggles on load.
        this.setTabsToggle();
        // Update tab toggles if tabs is updated.
        this.subscriptions.push(this.tabToggleDirectives.changes.subscribe(changes => {
            this.setTabsToggle();
        }));
    }
    /**
     * \@method ngOnChanges
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.activeTabIndex) {
            this.openTabIndex();
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
        removeSubscriptions(this.subscriptions);
    }
    /**
     * [toggleTab description]
     * \@method toggleTab
     * @return {?}
     */
    openTabIndex() {
        if (this.tabs) {
            this.tabs.forEach((tab) => {
                if (this.activatedTabIndex === tab.index || tab.index === 0 && typeof this.activatedTabIndex !== 'number') {
                    tab.isActive = true;
                    this.onOpen.emit({ index: tab.index });
                    this.changeDetectorRef.detectChanges();
                }
                else if (tab.isActive) {
                    tab.isActive = false;
                    this.onClose.emit({ index: tab.index });
                    this.changeDetectorRef.detectChanges();
                }
            });
        }
    }
    /**
     * [openTab description]
     * \@method openTab
     * @param {?} event
     * @param {?} tabToOpen
     * @return {?}
     */
    openTab(event, tabToOpen) {
        event.preventDefault();
        tabToOpen.isActive = true;
        this.onOpen.emit({ event, index: tabToOpen.index });
        this.tabs.forEach((tab) => {
            if (tab.isActive && tabToOpen !== tab) {
                tab.isActive = false;
                this.onClose.emit({ event, index: tab.index });
            }
        });
    }
    /**
     * [setTabIndex description]
     * \@method setTabIndex
     * @return {?}
     */
    setTabIndex() {
        this.tabs.forEach((tab, index) => {
            tab.index = index;
        });
        this.changeDetectorRef.detectChanges();
    }
    /**
     * [setTabsToggle description]
     * \@method setTabsToggle
     * @return {?}
     */
    setTabsToggle() {
        this.listeners = removeListeners(this.listeners);
        this.ngZone.runOutsideAngular(() => {
            this.tabToggleDirectives.forEach((tabToggle) => {
                this.listeners.push(this.renderer2.listen(tabToggle.elementRef.nativeElement, 'click', (event) => {
                    this.openTab(event, tabToggle.tabComponent);
                    this.changeDetectorRef.detectChanges();
                }));
            });
        });
    }
}
TabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tabs',
                template: `
    <div [ngClass]="styleClass">
      <ul [ngClass]="navStyleClass" [class.pull-right]="header || tabsHeaderComponent">
        <li *ngFor="let tab of tabs" [class.active]="tab.isActive" [mkColor]="tab.tabColor || tabsColor" mkColorProperty="border-top-color">
          <a *ngIf="!tab.isDisabled" [mkTabToggle]="tab" href="#">
            {{tab.header}}
            <ng-template *ngIf="!tab.header" [ngTemplateOutlet]="tab.tabHeaderComponent?.templateRef"></ng-template>
          </a>
          <ng-template [ngIf]="tab.isDisabled">
            {{tab.header}}
            <ng-template *ngIf="!tab.header" [ngTemplateOutlet]="tab.tabHeaderComponent.templateRef"></ng-template>
          </ng-template>
        </li>
        <li *ngIf="tabsHeaderComponent || header" [ngClass]="headerStyleClass">
          {{header}}
          <ng-template *ngIf="!header" [ngTemplateOutlet]="tabsHeaderComponent.templateRef"></ng-template>
        </li>
      </ul>
      <div [ngClass]="contentStyleClass">
        <div *ngFor="let tab of tabs" class="tab-pane" [class.active]="tab.isActive">
          <ng-template [ngTemplateOutlet]="tab.contentTemplateRef"></ng-template>
        </div>
      </div>
    </div>
  `,
                styles: [`
    .nav-tabs-custom > .nav-tabs > li {
      border-top-width: 0;
    }

    .nav-tabs-custom > .nav-tabs > li.active {
      border-top-width: 3px;
    }
  `],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
TabsComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: NgZone, },
    { type: Renderer2, },
];
TabsComponent.propDecorators = {
    'activeTabIndex': [{ type: Input },],
    'header': [{ type: Input },],
    'headerStyleClass': [{ type: Input },],
    'navStyleClass': [{ type: Input },],
    'contentStyleClass': [{ type: Input },],
    'styleClass': [{ type: Input },],
    'tabsColor': [{ type: Input },],
    'onClose': [{ type: Output },],
    'onOpen': [{ type: Output },],
    'tabsHeaderComponent': [{ type: ContentChild, args: [TabsHeaderComponent,] },],
    'tabs': [{ type: ContentChildren, args: [TabComponent,] },],
    'tabToggleDirectives': [{ type: ViewChildren, args: [TabToggleDirective,] },],
};

class TabsModule {
}
TabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ColorModule],
                exports: [TabsComponent, TabsHeaderComponent, TabComponent, TabHeaderComponent, TabContentComponent],
                declarations: [TabToggleDirective, TabsComponent, TabsHeaderComponent, TabComponent, TabHeaderComponent, TabContentComponent]
            },] },
];
/**
 * @nocollapse
 */
TabsModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { LayoutModule, LayoutService, LayoutStore, AccordionModule, AlertModule, BoxModule, BoxInfoModule, BoxSmallModule, BreadcrumbsModule, DropdownModule, InputTextModule, TabsModule, AccordionComponent as bh, AccordionContentComponent as bg, AccordionGroupComponent as bi, AccordionHeaderComponent as bf, AccordionToggleDirective as bj, AlertComponent as bk, CollapseAnimationDirective as r, AnimationsModule as q, BoxInfoComponent as bq, BoxInfoContentDirective as br, BoxInfoFooterDirective as bs, BoxInfoHeaderDirective as bt, BoxSmallComponent as bu, BoxSmallContentDirective as bx, BoxSmallFooterDirective as bv, BoxSmallHeaderDirective as bw, BoxComponent as bl, BoxContentDirective as bm, BoxFooterDirective as bn, BoxHeaderDirective as bp, BoxToolsDirective as bo, BreadcrumbsComponent as b, BackgroundColorDirective as bd, ColorDirective as be, ColorModule as bc, DropdownComponent as ca, DropdownMenuComponent as bz, DropdownToggleComponent as by, InputTextComponent as cb, InputTextAddonLeftDirective as cd, InputTextAddonRightDirective as ce, InputTextLabelDirective as cc, ContentComponent as d, ContentModule as a, FooterComponent as k, FooterLeftComponent as i, FooterRightComponent as j, FooterModule as h, FooterService as g, HeaderComponent as o, HeaderLogoComponent as m, HeaderLogoMiniComponent as n, HeaderModule as l, HeaderService as f, LayoutConfigToken as z, layoutProvider as bb, layoutStoreFactory as ba, SidebarLeftComponent as s, SidebarLeftToggleDirective as t, SidebarLeftModule as p, SidebarRightComponent as w, SidebarRightModule as v, SidebarRightService as e, WrapperComponent as y, WrapperModule as x, WrapperService as u, RoutingService as c, TabComponent as ch, TabContentComponent as cg, TabHeaderComponent as cf, TabsComponent as cj, TabsHeaderComponent as ci, TabToggleDirective as ck };
//# sourceMappingURL=angular-admin-lte.js.map
